// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/cloudreve/Cloudreve/v4/ent/davaccount"
	"github.com/cloudreve/Cloudreve/v4/ent/directlink"
	"github.com/cloudreve/Cloudreve/v4/ent/entity"
	"github.com/cloudreve/Cloudreve/v4/ent/file"
	"github.com/cloudreve/Cloudreve/v4/ent/group"
	"github.com/cloudreve/Cloudreve/v4/ent/metadata"
	"github.com/cloudreve/Cloudreve/v4/ent/node"
	"github.com/cloudreve/Cloudreve/v4/ent/passkey"
	"github.com/cloudreve/Cloudreve/v4/ent/predicate"
	"github.com/cloudreve/Cloudreve/v4/ent/setting"
	"github.com/cloudreve/Cloudreve/v4/ent/share"
	"github.com/cloudreve/Cloudreve/v4/ent/storagepolicy"
	"github.com/cloudreve/Cloudreve/v4/ent/task"
	"github.com/cloudreve/Cloudreve/v4/ent/user"
	"github.com/cloudreve/Cloudreve/v4/inventory/types"
	"github.com/cloudreve/Cloudreve/v4/pkg/boolset"
	"github.com/go-webauthn/webauthn/webauthn"
	"github.com/gofrs/uuid"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeDavAccount    = "DavAccount"
	TypeDirectLink    = "DirectLink"
	TypeEntity        = "Entity"
	TypeFile          = "File"
	TypeGroup         = "Group"
	TypeMetadata      = "Metadata"
	TypeNode          = "Node"
	TypePasskey       = "Passkey"
	TypeSetting       = "Setting"
	TypeShare         = "Share"
	TypeStoragePolicy = "StoragePolicy"
	TypeTask          = "Task"
	TypeUser          = "User"
)

// DavAccountMutation represents an operation that mutates the DavAccount nodes in the graph.
type DavAccountMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	name          *string
	uri           *string
	password      *string
	options       **boolset.BooleanSet
	props         **types.DavAccountProps
	clearedFields map[string]struct{}
	owner         *int
	clearedowner  bool
	done          bool
	oldValue      func(context.Context) (*DavAccount, error)
	predicates    []predicate.DavAccount
}

var _ ent.Mutation = (*DavAccountMutation)(nil)

// davaccountOption allows management of the mutation configuration using functional options.
type davaccountOption func(*DavAccountMutation)

// newDavAccountMutation creates new mutation for the DavAccount entity.
func newDavAccountMutation(c config, op Op, opts ...davaccountOption) *DavAccountMutation {
	m := &DavAccountMutation{
		config:        c,
		op:            op,
		typ:           TypeDavAccount,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDavAccountID sets the ID field of the mutation.
func withDavAccountID(id int) davaccountOption {
	return func(m *DavAccountMutation) {
		var (
			err   error
			once  sync.Once
			value *DavAccount
		)
		m.oldValue = func(ctx context.Context) (*DavAccount, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DavAccount.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDavAccount sets the old DavAccount of the mutation.
func withDavAccount(node *DavAccount) davaccountOption {
	return func(m *DavAccountMutation) {
		m.oldValue = func(context.Context) (*DavAccount, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DavAccountMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DavAccountMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DavAccountMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DavAccountMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DavAccount.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *DavAccountMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DavAccountMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the DavAccount entity.
// If the DavAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DavAccountMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DavAccountMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DavAccountMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DavAccountMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the DavAccount entity.
// If the DavAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DavAccountMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DavAccountMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *DavAccountMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *DavAccountMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the DavAccount entity.
// If the DavAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DavAccountMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *DavAccountMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[davaccount.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *DavAccountMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[davaccount.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *DavAccountMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, davaccount.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *DavAccountMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *DavAccountMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the DavAccount entity.
// If the DavAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DavAccountMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *DavAccountMutation) ResetName() {
	m.name = nil
}

// SetURI sets the "uri" field.
func (m *DavAccountMutation) SetURI(s string) {
	m.uri = &s
}

// URI returns the value of the "uri" field in the mutation.
func (m *DavAccountMutation) URI() (r string, exists bool) {
	v := m.uri
	if v == nil {
		return
	}
	return *v, true
}

// OldURI returns the old "uri" field's value of the DavAccount entity.
// If the DavAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DavAccountMutation) OldURI(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURI is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURI requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURI: %w", err)
	}
	return oldValue.URI, nil
}

// ResetURI resets all changes to the "uri" field.
func (m *DavAccountMutation) ResetURI() {
	m.uri = nil
}

// SetPassword sets the "password" field.
func (m *DavAccountMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *DavAccountMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the DavAccount entity.
// If the DavAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DavAccountMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *DavAccountMutation) ResetPassword() {
	m.password = nil
}

// SetOptions sets the "options" field.
func (m *DavAccountMutation) SetOptions(bs *boolset.BooleanSet) {
	m.options = &bs
}

// Options returns the value of the "options" field in the mutation.
func (m *DavAccountMutation) Options() (r *boolset.BooleanSet, exists bool) {
	v := m.options
	if v == nil {
		return
	}
	return *v, true
}

// OldOptions returns the old "options" field's value of the DavAccount entity.
// If the DavAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DavAccountMutation) OldOptions(ctx context.Context) (v *boolset.BooleanSet, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOptions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOptions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOptions: %w", err)
	}
	return oldValue.Options, nil
}

// ResetOptions resets all changes to the "options" field.
func (m *DavAccountMutation) ResetOptions() {
	m.options = nil
}

// SetProps sets the "props" field.
func (m *DavAccountMutation) SetProps(tap *types.DavAccountProps) {
	m.props = &tap
}

// Props returns the value of the "props" field in the mutation.
func (m *DavAccountMutation) Props() (r *types.DavAccountProps, exists bool) {
	v := m.props
	if v == nil {
		return
	}
	return *v, true
}

// OldProps returns the old "props" field's value of the DavAccount entity.
// If the DavAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DavAccountMutation) OldProps(ctx context.Context) (v *types.DavAccountProps, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProps is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProps requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProps: %w", err)
	}
	return oldValue.Props, nil
}

// ClearProps clears the value of the "props" field.
func (m *DavAccountMutation) ClearProps() {
	m.props = nil
	m.clearedFields[davaccount.FieldProps] = struct{}{}
}

// PropsCleared returns if the "props" field was cleared in this mutation.
func (m *DavAccountMutation) PropsCleared() bool {
	_, ok := m.clearedFields[davaccount.FieldProps]
	return ok
}

// ResetProps resets all changes to the "props" field.
func (m *DavAccountMutation) ResetProps() {
	m.props = nil
	delete(m.clearedFields, davaccount.FieldProps)
}

// SetOwnerID sets the "owner_id" field.
func (m *DavAccountMutation) SetOwnerID(i int) {
	m.owner = &i
}

// OwnerID returns the value of the "owner_id" field in the mutation.
func (m *DavAccountMutation) OwnerID() (r int, exists bool) {
	v := m.owner
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerID returns the old "owner_id" field's value of the DavAccount entity.
// If the DavAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DavAccountMutation) OldOwnerID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerID: %w", err)
	}
	return oldValue.OwnerID, nil
}

// ResetOwnerID resets all changes to the "owner_id" field.
func (m *DavAccountMutation) ResetOwnerID() {
	m.owner = nil
}

// ClearOwner clears the "owner" edge to the User entity.
func (m *DavAccountMutation) ClearOwner() {
	m.clearedowner = true
	m.clearedFields[davaccount.FieldOwnerID] = struct{}{}
}

// OwnerCleared reports if the "owner" edge to the User entity was cleared.
func (m *DavAccountMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *DavAccountMutation) OwnerIDs() (ids []int) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *DavAccountMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// Where appends a list predicates to the DavAccountMutation builder.
func (m *DavAccountMutation) Where(ps ...predicate.DavAccount) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DavAccountMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DavAccountMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DavAccount, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DavAccountMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DavAccountMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DavAccount).
func (m *DavAccountMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DavAccountMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, davaccount.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, davaccount.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, davaccount.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, davaccount.FieldName)
	}
	if m.uri != nil {
		fields = append(fields, davaccount.FieldURI)
	}
	if m.password != nil {
		fields = append(fields, davaccount.FieldPassword)
	}
	if m.options != nil {
		fields = append(fields, davaccount.FieldOptions)
	}
	if m.props != nil {
		fields = append(fields, davaccount.FieldProps)
	}
	if m.owner != nil {
		fields = append(fields, davaccount.FieldOwnerID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DavAccountMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case davaccount.FieldCreatedAt:
		return m.CreatedAt()
	case davaccount.FieldUpdatedAt:
		return m.UpdatedAt()
	case davaccount.FieldDeletedAt:
		return m.DeletedAt()
	case davaccount.FieldName:
		return m.Name()
	case davaccount.FieldURI:
		return m.URI()
	case davaccount.FieldPassword:
		return m.Password()
	case davaccount.FieldOptions:
		return m.Options()
	case davaccount.FieldProps:
		return m.Props()
	case davaccount.FieldOwnerID:
		return m.OwnerID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DavAccountMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case davaccount.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case davaccount.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case davaccount.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case davaccount.FieldName:
		return m.OldName(ctx)
	case davaccount.FieldURI:
		return m.OldURI(ctx)
	case davaccount.FieldPassword:
		return m.OldPassword(ctx)
	case davaccount.FieldOptions:
		return m.OldOptions(ctx)
	case davaccount.FieldProps:
		return m.OldProps(ctx)
	case davaccount.FieldOwnerID:
		return m.OldOwnerID(ctx)
	}
	return nil, fmt.Errorf("unknown DavAccount field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DavAccountMutation) SetField(name string, value ent.Value) error {
	switch name {
	case davaccount.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case davaccount.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case davaccount.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case davaccount.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case davaccount.FieldURI:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURI(v)
		return nil
	case davaccount.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case davaccount.FieldOptions:
		v, ok := value.(*boolset.BooleanSet)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOptions(v)
		return nil
	case davaccount.FieldProps:
		v, ok := value.(*types.DavAccountProps)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProps(v)
		return nil
	case davaccount.FieldOwnerID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerID(v)
		return nil
	}
	return fmt.Errorf("unknown DavAccount field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DavAccountMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DavAccountMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DavAccountMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown DavAccount numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DavAccountMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(davaccount.FieldDeletedAt) {
		fields = append(fields, davaccount.FieldDeletedAt)
	}
	if m.FieldCleared(davaccount.FieldProps) {
		fields = append(fields, davaccount.FieldProps)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DavAccountMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DavAccountMutation) ClearField(name string) error {
	switch name {
	case davaccount.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case davaccount.FieldProps:
		m.ClearProps()
		return nil
	}
	return fmt.Errorf("unknown DavAccount nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DavAccountMutation) ResetField(name string) error {
	switch name {
	case davaccount.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case davaccount.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case davaccount.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case davaccount.FieldName:
		m.ResetName()
		return nil
	case davaccount.FieldURI:
		m.ResetURI()
		return nil
	case davaccount.FieldPassword:
		m.ResetPassword()
		return nil
	case davaccount.FieldOptions:
		m.ResetOptions()
		return nil
	case davaccount.FieldProps:
		m.ResetProps()
		return nil
	case davaccount.FieldOwnerID:
		m.ResetOwnerID()
		return nil
	}
	return fmt.Errorf("unknown DavAccount field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DavAccountMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.owner != nil {
		edges = append(edges, davaccount.EdgeOwner)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DavAccountMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case davaccount.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DavAccountMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DavAccountMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DavAccountMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedowner {
		edges = append(edges, davaccount.EdgeOwner)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DavAccountMutation) EdgeCleared(name string) bool {
	switch name {
	case davaccount.EdgeOwner:
		return m.clearedowner
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DavAccountMutation) ClearEdge(name string) error {
	switch name {
	case davaccount.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown DavAccount unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DavAccountMutation) ResetEdge(name string) error {
	switch name {
	case davaccount.EdgeOwner:
		m.ResetOwner()
		return nil
	}
	return fmt.Errorf("unknown DavAccount edge %s", name)
}

// DirectLinkMutation represents an operation that mutates the DirectLink nodes in the graph.
type DirectLinkMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	name          *string
	downloads     *int
	adddownloads  *int
	speed         *int
	addspeed      *int
	clearedFields map[string]struct{}
	file          *int
	clearedfile   bool
	done          bool
	oldValue      func(context.Context) (*DirectLink, error)
	predicates    []predicate.DirectLink
}

var _ ent.Mutation = (*DirectLinkMutation)(nil)

// directlinkOption allows management of the mutation configuration using functional options.
type directlinkOption func(*DirectLinkMutation)

// newDirectLinkMutation creates new mutation for the DirectLink entity.
func newDirectLinkMutation(c config, op Op, opts ...directlinkOption) *DirectLinkMutation {
	m := &DirectLinkMutation{
		config:        c,
		op:            op,
		typ:           TypeDirectLink,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDirectLinkID sets the ID field of the mutation.
func withDirectLinkID(id int) directlinkOption {
	return func(m *DirectLinkMutation) {
		var (
			err   error
			once  sync.Once
			value *DirectLink
		)
		m.oldValue = func(ctx context.Context) (*DirectLink, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DirectLink.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDirectLink sets the old DirectLink of the mutation.
func withDirectLink(node *DirectLink) directlinkOption {
	return func(m *DirectLinkMutation) {
		m.oldValue = func(context.Context) (*DirectLink, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DirectLinkMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DirectLinkMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DirectLinkMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DirectLinkMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DirectLink.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *DirectLinkMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DirectLinkMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the DirectLink entity.
// If the DirectLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DirectLinkMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DirectLinkMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DirectLinkMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DirectLinkMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the DirectLink entity.
// If the DirectLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DirectLinkMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DirectLinkMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *DirectLinkMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *DirectLinkMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the DirectLink entity.
// If the DirectLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DirectLinkMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *DirectLinkMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[directlink.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *DirectLinkMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[directlink.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *DirectLinkMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, directlink.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *DirectLinkMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *DirectLinkMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the DirectLink entity.
// If the DirectLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DirectLinkMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *DirectLinkMutation) ResetName() {
	m.name = nil
}

// SetDownloads sets the "downloads" field.
func (m *DirectLinkMutation) SetDownloads(i int) {
	m.downloads = &i
	m.adddownloads = nil
}

// Downloads returns the value of the "downloads" field in the mutation.
func (m *DirectLinkMutation) Downloads() (r int, exists bool) {
	v := m.downloads
	if v == nil {
		return
	}
	return *v, true
}

// OldDownloads returns the old "downloads" field's value of the DirectLink entity.
// If the DirectLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DirectLinkMutation) OldDownloads(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDownloads is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDownloads requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDownloads: %w", err)
	}
	return oldValue.Downloads, nil
}

// AddDownloads adds i to the "downloads" field.
func (m *DirectLinkMutation) AddDownloads(i int) {
	if m.adddownloads != nil {
		*m.adddownloads += i
	} else {
		m.adddownloads = &i
	}
}

// AddedDownloads returns the value that was added to the "downloads" field in this mutation.
func (m *DirectLinkMutation) AddedDownloads() (r int, exists bool) {
	v := m.adddownloads
	if v == nil {
		return
	}
	return *v, true
}

// ResetDownloads resets all changes to the "downloads" field.
func (m *DirectLinkMutation) ResetDownloads() {
	m.downloads = nil
	m.adddownloads = nil
}

// SetFileID sets the "file_id" field.
func (m *DirectLinkMutation) SetFileID(i int) {
	m.file = &i
}

// FileID returns the value of the "file_id" field in the mutation.
func (m *DirectLinkMutation) FileID() (r int, exists bool) {
	v := m.file
	if v == nil {
		return
	}
	return *v, true
}

// OldFileID returns the old "file_id" field's value of the DirectLink entity.
// If the DirectLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DirectLinkMutation) OldFileID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFileID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFileID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFileID: %w", err)
	}
	return oldValue.FileID, nil
}

// ResetFileID resets all changes to the "file_id" field.
func (m *DirectLinkMutation) ResetFileID() {
	m.file = nil
}

// SetSpeed sets the "speed" field.
func (m *DirectLinkMutation) SetSpeed(i int) {
	m.speed = &i
	m.addspeed = nil
}

// Speed returns the value of the "speed" field in the mutation.
func (m *DirectLinkMutation) Speed() (r int, exists bool) {
	v := m.speed
	if v == nil {
		return
	}
	return *v, true
}

// OldSpeed returns the old "speed" field's value of the DirectLink entity.
// If the DirectLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DirectLinkMutation) OldSpeed(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSpeed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSpeed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpeed: %w", err)
	}
	return oldValue.Speed, nil
}

// AddSpeed adds i to the "speed" field.
func (m *DirectLinkMutation) AddSpeed(i int) {
	if m.addspeed != nil {
		*m.addspeed += i
	} else {
		m.addspeed = &i
	}
}

// AddedSpeed returns the value that was added to the "speed" field in this mutation.
func (m *DirectLinkMutation) AddedSpeed() (r int, exists bool) {
	v := m.addspeed
	if v == nil {
		return
	}
	return *v, true
}

// ResetSpeed resets all changes to the "speed" field.
func (m *DirectLinkMutation) ResetSpeed() {
	m.speed = nil
	m.addspeed = nil
}

// ClearFile clears the "file" edge to the File entity.
func (m *DirectLinkMutation) ClearFile() {
	m.clearedfile = true
	m.clearedFields[directlink.FieldFileID] = struct{}{}
}

// FileCleared reports if the "file" edge to the File entity was cleared.
func (m *DirectLinkMutation) FileCleared() bool {
	return m.clearedfile
}

// FileIDs returns the "file" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FileID instead. It exists only for internal usage by the builders.
func (m *DirectLinkMutation) FileIDs() (ids []int) {
	if id := m.file; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFile resets all changes to the "file" edge.
func (m *DirectLinkMutation) ResetFile() {
	m.file = nil
	m.clearedfile = false
}

// Where appends a list predicates to the DirectLinkMutation builder.
func (m *DirectLinkMutation) Where(ps ...predicate.DirectLink) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DirectLinkMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DirectLinkMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DirectLink, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DirectLinkMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DirectLinkMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DirectLink).
func (m *DirectLinkMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DirectLinkMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, directlink.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, directlink.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, directlink.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, directlink.FieldName)
	}
	if m.downloads != nil {
		fields = append(fields, directlink.FieldDownloads)
	}
	if m.file != nil {
		fields = append(fields, directlink.FieldFileID)
	}
	if m.speed != nil {
		fields = append(fields, directlink.FieldSpeed)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DirectLinkMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case directlink.FieldCreatedAt:
		return m.CreatedAt()
	case directlink.FieldUpdatedAt:
		return m.UpdatedAt()
	case directlink.FieldDeletedAt:
		return m.DeletedAt()
	case directlink.FieldName:
		return m.Name()
	case directlink.FieldDownloads:
		return m.Downloads()
	case directlink.FieldFileID:
		return m.FileID()
	case directlink.FieldSpeed:
		return m.Speed()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DirectLinkMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case directlink.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case directlink.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case directlink.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case directlink.FieldName:
		return m.OldName(ctx)
	case directlink.FieldDownloads:
		return m.OldDownloads(ctx)
	case directlink.FieldFileID:
		return m.OldFileID(ctx)
	case directlink.FieldSpeed:
		return m.OldSpeed(ctx)
	}
	return nil, fmt.Errorf("unknown DirectLink field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DirectLinkMutation) SetField(name string, value ent.Value) error {
	switch name {
	case directlink.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case directlink.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case directlink.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case directlink.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case directlink.FieldDownloads:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDownloads(v)
		return nil
	case directlink.FieldFileID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFileID(v)
		return nil
	case directlink.FieldSpeed:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpeed(v)
		return nil
	}
	return fmt.Errorf("unknown DirectLink field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DirectLinkMutation) AddedFields() []string {
	var fields []string
	if m.adddownloads != nil {
		fields = append(fields, directlink.FieldDownloads)
	}
	if m.addspeed != nil {
		fields = append(fields, directlink.FieldSpeed)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DirectLinkMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case directlink.FieldDownloads:
		return m.AddedDownloads()
	case directlink.FieldSpeed:
		return m.AddedSpeed()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DirectLinkMutation) AddField(name string, value ent.Value) error {
	switch name {
	case directlink.FieldDownloads:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDownloads(v)
		return nil
	case directlink.FieldSpeed:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSpeed(v)
		return nil
	}
	return fmt.Errorf("unknown DirectLink numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DirectLinkMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(directlink.FieldDeletedAt) {
		fields = append(fields, directlink.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DirectLinkMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DirectLinkMutation) ClearField(name string) error {
	switch name {
	case directlink.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown DirectLink nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DirectLinkMutation) ResetField(name string) error {
	switch name {
	case directlink.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case directlink.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case directlink.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case directlink.FieldName:
		m.ResetName()
		return nil
	case directlink.FieldDownloads:
		m.ResetDownloads()
		return nil
	case directlink.FieldFileID:
		m.ResetFileID()
		return nil
	case directlink.FieldSpeed:
		m.ResetSpeed()
		return nil
	}
	return fmt.Errorf("unknown DirectLink field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DirectLinkMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.file != nil {
		edges = append(edges, directlink.EdgeFile)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DirectLinkMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case directlink.EdgeFile:
		if id := m.file; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DirectLinkMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DirectLinkMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DirectLinkMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedfile {
		edges = append(edges, directlink.EdgeFile)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DirectLinkMutation) EdgeCleared(name string) bool {
	switch name {
	case directlink.EdgeFile:
		return m.clearedfile
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DirectLinkMutation) ClearEdge(name string) error {
	switch name {
	case directlink.EdgeFile:
		m.ClearFile()
		return nil
	}
	return fmt.Errorf("unknown DirectLink unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DirectLinkMutation) ResetEdge(name string) error {
	switch name {
	case directlink.EdgeFile:
		m.ResetFile()
		return nil
	}
	return fmt.Errorf("unknown DirectLink edge %s", name)
}

// EntityMutation represents an operation that mutates the Entity nodes in the graph.
type EntityMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	created_at            *time.Time
	updated_at            *time.Time
	deleted_at            *time.Time
	_type                 *int
	add_type              *int
	source                *string
	size                  *int64
	addsize               *int64
	reference_count       *int
	addreference_count    *int
	upload_session_id     *uuid.UUID
	recycle_options       **types.EntityRecycleOption
	clearedFields         map[string]struct{}
	file                  map[int]struct{}
	removedfile           map[int]struct{}
	clearedfile           bool
	user                  *int
	cleareduser           bool
	storage_policy        *int
	clearedstorage_policy bool
	done                  bool
	oldValue              func(context.Context) (*Entity, error)
	predicates            []predicate.Entity
}

var _ ent.Mutation = (*EntityMutation)(nil)

// entityOption allows management of the mutation configuration using functional options.
type entityOption func(*EntityMutation)

// newEntityMutation creates new mutation for the Entity entity.
func newEntityMutation(c config, op Op, opts ...entityOption) *EntityMutation {
	m := &EntityMutation{
		config:        c,
		op:            op,
		typ:           TypeEntity,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEntityID sets the ID field of the mutation.
func withEntityID(id int) entityOption {
	return func(m *EntityMutation) {
		var (
			err   error
			once  sync.Once
			value *Entity
		)
		m.oldValue = func(ctx context.Context) (*Entity, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Entity.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEntity sets the old Entity of the mutation.
func withEntity(node *Entity) entityOption {
	return func(m *EntityMutation) {
		m.oldValue = func(context.Context) (*Entity, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EntityMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EntityMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EntityMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EntityMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Entity.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *EntityMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EntityMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Entity entity.
// If the Entity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EntityMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EntityMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EntityMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Entity entity.
// If the Entity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EntityMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *EntityMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *EntityMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Entity entity.
// If the Entity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *EntityMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[entity.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *EntityMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[entity.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *EntityMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, entity.FieldDeletedAt)
}

// SetType sets the "type" field.
func (m *EntityMutation) SetType(i int) {
	m._type = &i
	m.add_type = nil
}

// GetType returns the value of the "type" field in the mutation.
func (m *EntityMutation) GetType() (r int, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Entity entity.
// If the Entity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityMutation) OldType(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// AddType adds i to the "type" field.
func (m *EntityMutation) AddType(i int) {
	if m.add_type != nil {
		*m.add_type += i
	} else {
		m.add_type = &i
	}
}

// AddedType returns the value that was added to the "type" field in this mutation.
func (m *EntityMutation) AddedType() (r int, exists bool) {
	v := m.add_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetType resets all changes to the "type" field.
func (m *EntityMutation) ResetType() {
	m._type = nil
	m.add_type = nil
}

// SetSource sets the "source" field.
func (m *EntityMutation) SetSource(s string) {
	m.source = &s
}

// Source returns the value of the "source" field in the mutation.
func (m *EntityMutation) Source() (r string, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSource returns the old "source" field's value of the Entity entity.
// If the Entity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityMutation) OldSource(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSource: %w", err)
	}
	return oldValue.Source, nil
}

// ResetSource resets all changes to the "source" field.
func (m *EntityMutation) ResetSource() {
	m.source = nil
}

// SetSize sets the "size" field.
func (m *EntityMutation) SetSize(i int64) {
	m.size = &i
	m.addsize = nil
}

// Size returns the value of the "size" field in the mutation.
func (m *EntityMutation) Size() (r int64, exists bool) {
	v := m.size
	if v == nil {
		return
	}
	return *v, true
}

// OldSize returns the old "size" field's value of the Entity entity.
// If the Entity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityMutation) OldSize(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSize: %w", err)
	}
	return oldValue.Size, nil
}

// AddSize adds i to the "size" field.
func (m *EntityMutation) AddSize(i int64) {
	if m.addsize != nil {
		*m.addsize += i
	} else {
		m.addsize = &i
	}
}

// AddedSize returns the value that was added to the "size" field in this mutation.
func (m *EntityMutation) AddedSize() (r int64, exists bool) {
	v := m.addsize
	if v == nil {
		return
	}
	return *v, true
}

// ResetSize resets all changes to the "size" field.
func (m *EntityMutation) ResetSize() {
	m.size = nil
	m.addsize = nil
}

// SetReferenceCount sets the "reference_count" field.
func (m *EntityMutation) SetReferenceCount(i int) {
	m.reference_count = &i
	m.addreference_count = nil
}

// ReferenceCount returns the value of the "reference_count" field in the mutation.
func (m *EntityMutation) ReferenceCount() (r int, exists bool) {
	v := m.reference_count
	if v == nil {
		return
	}
	return *v, true
}

// OldReferenceCount returns the old "reference_count" field's value of the Entity entity.
// If the Entity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityMutation) OldReferenceCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReferenceCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReferenceCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReferenceCount: %w", err)
	}
	return oldValue.ReferenceCount, nil
}

// AddReferenceCount adds i to the "reference_count" field.
func (m *EntityMutation) AddReferenceCount(i int) {
	if m.addreference_count != nil {
		*m.addreference_count += i
	} else {
		m.addreference_count = &i
	}
}

// AddedReferenceCount returns the value that was added to the "reference_count" field in this mutation.
func (m *EntityMutation) AddedReferenceCount() (r int, exists bool) {
	v := m.addreference_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetReferenceCount resets all changes to the "reference_count" field.
func (m *EntityMutation) ResetReferenceCount() {
	m.reference_count = nil
	m.addreference_count = nil
}

// SetStoragePolicyEntities sets the "storage_policy_entities" field.
func (m *EntityMutation) SetStoragePolicyEntities(i int) {
	m.storage_policy = &i
}

// StoragePolicyEntities returns the value of the "storage_policy_entities" field in the mutation.
func (m *EntityMutation) StoragePolicyEntities() (r int, exists bool) {
	v := m.storage_policy
	if v == nil {
		return
	}
	return *v, true
}

// OldStoragePolicyEntities returns the old "storage_policy_entities" field's value of the Entity entity.
// If the Entity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityMutation) OldStoragePolicyEntities(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStoragePolicyEntities is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStoragePolicyEntities requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStoragePolicyEntities: %w", err)
	}
	return oldValue.StoragePolicyEntities, nil
}

// ResetStoragePolicyEntities resets all changes to the "storage_policy_entities" field.
func (m *EntityMutation) ResetStoragePolicyEntities() {
	m.storage_policy = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *EntityMutation) SetCreatedBy(i int) {
	m.user = &i
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *EntityMutation) CreatedBy() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Entity entity.
// If the Entity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityMutation) OldCreatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *EntityMutation) ClearCreatedBy() {
	m.user = nil
	m.clearedFields[entity.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *EntityMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[entity.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *EntityMutation) ResetCreatedBy() {
	m.user = nil
	delete(m.clearedFields, entity.FieldCreatedBy)
}

// SetUploadSessionID sets the "upload_session_id" field.
func (m *EntityMutation) SetUploadSessionID(u uuid.UUID) {
	m.upload_session_id = &u
}

// UploadSessionID returns the value of the "upload_session_id" field in the mutation.
func (m *EntityMutation) UploadSessionID() (r uuid.UUID, exists bool) {
	v := m.upload_session_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUploadSessionID returns the old "upload_session_id" field's value of the Entity entity.
// If the Entity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityMutation) OldUploadSessionID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUploadSessionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUploadSessionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUploadSessionID: %w", err)
	}
	return oldValue.UploadSessionID, nil
}

// ClearUploadSessionID clears the value of the "upload_session_id" field.
func (m *EntityMutation) ClearUploadSessionID() {
	m.upload_session_id = nil
	m.clearedFields[entity.FieldUploadSessionID] = struct{}{}
}

// UploadSessionIDCleared returns if the "upload_session_id" field was cleared in this mutation.
func (m *EntityMutation) UploadSessionIDCleared() bool {
	_, ok := m.clearedFields[entity.FieldUploadSessionID]
	return ok
}

// ResetUploadSessionID resets all changes to the "upload_session_id" field.
func (m *EntityMutation) ResetUploadSessionID() {
	m.upload_session_id = nil
	delete(m.clearedFields, entity.FieldUploadSessionID)
}

// SetRecycleOptions sets the "recycle_options" field.
func (m *EntityMutation) SetRecycleOptions(tro *types.EntityRecycleOption) {
	m.recycle_options = &tro
}

// RecycleOptions returns the value of the "recycle_options" field in the mutation.
func (m *EntityMutation) RecycleOptions() (r *types.EntityRecycleOption, exists bool) {
	v := m.recycle_options
	if v == nil {
		return
	}
	return *v, true
}

// OldRecycleOptions returns the old "recycle_options" field's value of the Entity entity.
// If the Entity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityMutation) OldRecycleOptions(ctx context.Context) (v *types.EntityRecycleOption, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRecycleOptions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRecycleOptions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRecycleOptions: %w", err)
	}
	return oldValue.RecycleOptions, nil
}

// ClearRecycleOptions clears the value of the "recycle_options" field.
func (m *EntityMutation) ClearRecycleOptions() {
	m.recycle_options = nil
	m.clearedFields[entity.FieldRecycleOptions] = struct{}{}
}

// RecycleOptionsCleared returns if the "recycle_options" field was cleared in this mutation.
func (m *EntityMutation) RecycleOptionsCleared() bool {
	_, ok := m.clearedFields[entity.FieldRecycleOptions]
	return ok
}

// ResetRecycleOptions resets all changes to the "recycle_options" field.
func (m *EntityMutation) ResetRecycleOptions() {
	m.recycle_options = nil
	delete(m.clearedFields, entity.FieldRecycleOptions)
}

// AddFileIDs adds the "file" edge to the File entity by ids.
func (m *EntityMutation) AddFileIDs(ids ...int) {
	if m.file == nil {
		m.file = make(map[int]struct{})
	}
	for i := range ids {
		m.file[ids[i]] = struct{}{}
	}
}

// ClearFile clears the "file" edge to the File entity.
func (m *EntityMutation) ClearFile() {
	m.clearedfile = true
}

// FileCleared reports if the "file" edge to the File entity was cleared.
func (m *EntityMutation) FileCleared() bool {
	return m.clearedfile
}

// RemoveFileIDs removes the "file" edge to the File entity by IDs.
func (m *EntityMutation) RemoveFileIDs(ids ...int) {
	if m.removedfile == nil {
		m.removedfile = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.file, ids[i])
		m.removedfile[ids[i]] = struct{}{}
	}
}

// RemovedFile returns the removed IDs of the "file" edge to the File entity.
func (m *EntityMutation) RemovedFileIDs() (ids []int) {
	for id := range m.removedfile {
		ids = append(ids, id)
	}
	return
}

// FileIDs returns the "file" edge IDs in the mutation.
func (m *EntityMutation) FileIDs() (ids []int) {
	for id := range m.file {
		ids = append(ids, id)
	}
	return
}

// ResetFile resets all changes to the "file" edge.
func (m *EntityMutation) ResetFile() {
	m.file = nil
	m.clearedfile = false
	m.removedfile = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *EntityMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *EntityMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[entity.FieldCreatedBy] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *EntityMutation) UserCleared() bool {
	return m.CreatedByCleared() || m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *EntityMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *EntityMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *EntityMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// SetStoragePolicyID sets the "storage_policy" edge to the StoragePolicy entity by id.
func (m *EntityMutation) SetStoragePolicyID(id int) {
	m.storage_policy = &id
}

// ClearStoragePolicy clears the "storage_policy" edge to the StoragePolicy entity.
func (m *EntityMutation) ClearStoragePolicy() {
	m.clearedstorage_policy = true
	m.clearedFields[entity.FieldStoragePolicyEntities] = struct{}{}
}

// StoragePolicyCleared reports if the "storage_policy" edge to the StoragePolicy entity was cleared.
func (m *EntityMutation) StoragePolicyCleared() bool {
	return m.clearedstorage_policy
}

// StoragePolicyID returns the "storage_policy" edge ID in the mutation.
func (m *EntityMutation) StoragePolicyID() (id int, exists bool) {
	if m.storage_policy != nil {
		return *m.storage_policy, true
	}
	return
}

// StoragePolicyIDs returns the "storage_policy" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StoragePolicyID instead. It exists only for internal usage by the builders.
func (m *EntityMutation) StoragePolicyIDs() (ids []int) {
	if id := m.storage_policy; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStoragePolicy resets all changes to the "storage_policy" edge.
func (m *EntityMutation) ResetStoragePolicy() {
	m.storage_policy = nil
	m.clearedstorage_policy = false
}

// Where appends a list predicates to the EntityMutation builder.
func (m *EntityMutation) Where(ps ...predicate.Entity) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EntityMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EntityMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Entity, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EntityMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EntityMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Entity).
func (m *EntityMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EntityMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.created_at != nil {
		fields = append(fields, entity.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, entity.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, entity.FieldDeletedAt)
	}
	if m._type != nil {
		fields = append(fields, entity.FieldType)
	}
	if m.source != nil {
		fields = append(fields, entity.FieldSource)
	}
	if m.size != nil {
		fields = append(fields, entity.FieldSize)
	}
	if m.reference_count != nil {
		fields = append(fields, entity.FieldReferenceCount)
	}
	if m.storage_policy != nil {
		fields = append(fields, entity.FieldStoragePolicyEntities)
	}
	if m.user != nil {
		fields = append(fields, entity.FieldCreatedBy)
	}
	if m.upload_session_id != nil {
		fields = append(fields, entity.FieldUploadSessionID)
	}
	if m.recycle_options != nil {
		fields = append(fields, entity.FieldRecycleOptions)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EntityMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case entity.FieldCreatedAt:
		return m.CreatedAt()
	case entity.FieldUpdatedAt:
		return m.UpdatedAt()
	case entity.FieldDeletedAt:
		return m.DeletedAt()
	case entity.FieldType:
		return m.GetType()
	case entity.FieldSource:
		return m.Source()
	case entity.FieldSize:
		return m.Size()
	case entity.FieldReferenceCount:
		return m.ReferenceCount()
	case entity.FieldStoragePolicyEntities:
		return m.StoragePolicyEntities()
	case entity.FieldCreatedBy:
		return m.CreatedBy()
	case entity.FieldUploadSessionID:
		return m.UploadSessionID()
	case entity.FieldRecycleOptions:
		return m.RecycleOptions()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EntityMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case entity.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case entity.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case entity.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case entity.FieldType:
		return m.OldType(ctx)
	case entity.FieldSource:
		return m.OldSource(ctx)
	case entity.FieldSize:
		return m.OldSize(ctx)
	case entity.FieldReferenceCount:
		return m.OldReferenceCount(ctx)
	case entity.FieldStoragePolicyEntities:
		return m.OldStoragePolicyEntities(ctx)
	case entity.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case entity.FieldUploadSessionID:
		return m.OldUploadSessionID(ctx)
	case entity.FieldRecycleOptions:
		return m.OldRecycleOptions(ctx)
	}
	return nil, fmt.Errorf("unknown Entity field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EntityMutation) SetField(name string, value ent.Value) error {
	switch name {
	case entity.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case entity.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case entity.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case entity.FieldType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case entity.FieldSource:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSource(v)
		return nil
	case entity.FieldSize:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSize(v)
		return nil
	case entity.FieldReferenceCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReferenceCount(v)
		return nil
	case entity.FieldStoragePolicyEntities:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStoragePolicyEntities(v)
		return nil
	case entity.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case entity.FieldUploadSessionID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUploadSessionID(v)
		return nil
	case entity.FieldRecycleOptions:
		v, ok := value.(*types.EntityRecycleOption)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRecycleOptions(v)
		return nil
	}
	return fmt.Errorf("unknown Entity field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EntityMutation) AddedFields() []string {
	var fields []string
	if m.add_type != nil {
		fields = append(fields, entity.FieldType)
	}
	if m.addsize != nil {
		fields = append(fields, entity.FieldSize)
	}
	if m.addreference_count != nil {
		fields = append(fields, entity.FieldReferenceCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EntityMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case entity.FieldType:
		return m.AddedType()
	case entity.FieldSize:
		return m.AddedSize()
	case entity.FieldReferenceCount:
		return m.AddedReferenceCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EntityMutation) AddField(name string, value ent.Value) error {
	switch name {
	case entity.FieldType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddType(v)
		return nil
	case entity.FieldSize:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSize(v)
		return nil
	case entity.FieldReferenceCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddReferenceCount(v)
		return nil
	}
	return fmt.Errorf("unknown Entity numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EntityMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(entity.FieldDeletedAt) {
		fields = append(fields, entity.FieldDeletedAt)
	}
	if m.FieldCleared(entity.FieldCreatedBy) {
		fields = append(fields, entity.FieldCreatedBy)
	}
	if m.FieldCleared(entity.FieldUploadSessionID) {
		fields = append(fields, entity.FieldUploadSessionID)
	}
	if m.FieldCleared(entity.FieldRecycleOptions) {
		fields = append(fields, entity.FieldRecycleOptions)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EntityMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EntityMutation) ClearField(name string) error {
	switch name {
	case entity.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case entity.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case entity.FieldUploadSessionID:
		m.ClearUploadSessionID()
		return nil
	case entity.FieldRecycleOptions:
		m.ClearRecycleOptions()
		return nil
	}
	return fmt.Errorf("unknown Entity nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EntityMutation) ResetField(name string) error {
	switch name {
	case entity.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case entity.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case entity.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case entity.FieldType:
		m.ResetType()
		return nil
	case entity.FieldSource:
		m.ResetSource()
		return nil
	case entity.FieldSize:
		m.ResetSize()
		return nil
	case entity.FieldReferenceCount:
		m.ResetReferenceCount()
		return nil
	case entity.FieldStoragePolicyEntities:
		m.ResetStoragePolicyEntities()
		return nil
	case entity.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case entity.FieldUploadSessionID:
		m.ResetUploadSessionID()
		return nil
	case entity.FieldRecycleOptions:
		m.ResetRecycleOptions()
		return nil
	}
	return fmt.Errorf("unknown Entity field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EntityMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.file != nil {
		edges = append(edges, entity.EdgeFile)
	}
	if m.user != nil {
		edges = append(edges, entity.EdgeUser)
	}
	if m.storage_policy != nil {
		edges = append(edges, entity.EdgeStoragePolicy)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EntityMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case entity.EdgeFile:
		ids := make([]ent.Value, 0, len(m.file))
		for id := range m.file {
			ids = append(ids, id)
		}
		return ids
	case entity.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case entity.EdgeStoragePolicy:
		if id := m.storage_policy; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EntityMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedfile != nil {
		edges = append(edges, entity.EdgeFile)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EntityMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case entity.EdgeFile:
		ids := make([]ent.Value, 0, len(m.removedfile))
		for id := range m.removedfile {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EntityMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedfile {
		edges = append(edges, entity.EdgeFile)
	}
	if m.cleareduser {
		edges = append(edges, entity.EdgeUser)
	}
	if m.clearedstorage_policy {
		edges = append(edges, entity.EdgeStoragePolicy)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EntityMutation) EdgeCleared(name string) bool {
	switch name {
	case entity.EdgeFile:
		return m.clearedfile
	case entity.EdgeUser:
		return m.cleareduser
	case entity.EdgeStoragePolicy:
		return m.clearedstorage_policy
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EntityMutation) ClearEdge(name string) error {
	switch name {
	case entity.EdgeUser:
		m.ClearUser()
		return nil
	case entity.EdgeStoragePolicy:
		m.ClearStoragePolicy()
		return nil
	}
	return fmt.Errorf("unknown Entity unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EntityMutation) ResetEdge(name string) error {
	switch name {
	case entity.EdgeFile:
		m.ResetFile()
		return nil
	case entity.EdgeUser:
		m.ResetUser()
		return nil
	case entity.EdgeStoragePolicy:
		m.ResetStoragePolicy()
		return nil
	}
	return fmt.Errorf("unknown Entity edge %s", name)
}

// FileMutation represents an operation that mutates the File nodes in the graph.
type FileMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int
	created_at              *time.Time
	updated_at              *time.Time
	deleted_at              *time.Time
	_type                   *int
	add_type                *int
	name                    *string
	size                    *int64
	addsize                 *int64
	primary_entity          *int
	addprimary_entity       *int
	is_symbolic             *bool
	props                   **types.FileProps
	clearedFields           map[string]struct{}
	owner                   *int
	clearedowner            bool
	storage_policies        *int
	clearedstorage_policies bool
	parent                  *int
	clearedparent           bool
	children                map[int]struct{}
	removedchildren         map[int]struct{}
	clearedchildren         bool
	metadata                map[int]struct{}
	removedmetadata         map[int]struct{}
	clearedmetadata         bool
	entities                map[int]struct{}
	removedentities         map[int]struct{}
	clearedentities         bool
	shares                  map[int]struct{}
	removedshares           map[int]struct{}
	clearedshares           bool
	direct_links            map[int]struct{}
	removeddirect_links     map[int]struct{}
	cleareddirect_links     bool
	done                    bool
	oldValue                func(context.Context) (*File, error)
	predicates              []predicate.File
}

var _ ent.Mutation = (*FileMutation)(nil)

// fileOption allows management of the mutation configuration using functional options.
type fileOption func(*FileMutation)

// newFileMutation creates new mutation for the File entity.
func newFileMutation(c config, op Op, opts ...fileOption) *FileMutation {
	m := &FileMutation{
		config:        c,
		op:            op,
		typ:           TypeFile,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFileID sets the ID field of the mutation.
func withFileID(id int) fileOption {
	return func(m *FileMutation) {
		var (
			err   error
			once  sync.Once
			value *File
		)
		m.oldValue = func(ctx context.Context) (*File, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().File.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFile sets the old File of the mutation.
func withFile(node *File) fileOption {
	return func(m *FileMutation) {
		m.oldValue = func(context.Context) (*File, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FileMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FileMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FileMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FileMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().File.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *FileMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *FileMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *FileMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *FileMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *FileMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *FileMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *FileMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *FileMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *FileMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[file.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *FileMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[file.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *FileMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, file.FieldDeletedAt)
}

// SetType sets the "type" field.
func (m *FileMutation) SetType(i int) {
	m._type = &i
	m.add_type = nil
}

// GetType returns the value of the "type" field in the mutation.
func (m *FileMutation) GetType() (r int, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldType(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// AddType adds i to the "type" field.
func (m *FileMutation) AddType(i int) {
	if m.add_type != nil {
		*m.add_type += i
	} else {
		m.add_type = &i
	}
}

// AddedType returns the value that was added to the "type" field in this mutation.
func (m *FileMutation) AddedType() (r int, exists bool) {
	v := m.add_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetType resets all changes to the "type" field.
func (m *FileMutation) ResetType() {
	m._type = nil
	m.add_type = nil
}

// SetName sets the "name" field.
func (m *FileMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *FileMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *FileMutation) ResetName() {
	m.name = nil
}

// SetOwnerID sets the "owner_id" field.
func (m *FileMutation) SetOwnerID(i int) {
	m.owner = &i
}

// OwnerID returns the value of the "owner_id" field in the mutation.
func (m *FileMutation) OwnerID() (r int, exists bool) {
	v := m.owner
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerID returns the old "owner_id" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldOwnerID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerID: %w", err)
	}
	return oldValue.OwnerID, nil
}

// ResetOwnerID resets all changes to the "owner_id" field.
func (m *FileMutation) ResetOwnerID() {
	m.owner = nil
}

// SetSize sets the "size" field.
func (m *FileMutation) SetSize(i int64) {
	m.size = &i
	m.addsize = nil
}

// Size returns the value of the "size" field in the mutation.
func (m *FileMutation) Size() (r int64, exists bool) {
	v := m.size
	if v == nil {
		return
	}
	return *v, true
}

// OldSize returns the old "size" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldSize(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSize: %w", err)
	}
	return oldValue.Size, nil
}

// AddSize adds i to the "size" field.
func (m *FileMutation) AddSize(i int64) {
	if m.addsize != nil {
		*m.addsize += i
	} else {
		m.addsize = &i
	}
}

// AddedSize returns the value that was added to the "size" field in this mutation.
func (m *FileMutation) AddedSize() (r int64, exists bool) {
	v := m.addsize
	if v == nil {
		return
	}
	return *v, true
}

// ResetSize resets all changes to the "size" field.
func (m *FileMutation) ResetSize() {
	m.size = nil
	m.addsize = nil
}

// SetPrimaryEntity sets the "primary_entity" field.
func (m *FileMutation) SetPrimaryEntity(i int) {
	m.primary_entity = &i
	m.addprimary_entity = nil
}

// PrimaryEntity returns the value of the "primary_entity" field in the mutation.
func (m *FileMutation) PrimaryEntity() (r int, exists bool) {
	v := m.primary_entity
	if v == nil {
		return
	}
	return *v, true
}

// OldPrimaryEntity returns the old "primary_entity" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldPrimaryEntity(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrimaryEntity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrimaryEntity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrimaryEntity: %w", err)
	}
	return oldValue.PrimaryEntity, nil
}

// AddPrimaryEntity adds i to the "primary_entity" field.
func (m *FileMutation) AddPrimaryEntity(i int) {
	if m.addprimary_entity != nil {
		*m.addprimary_entity += i
	} else {
		m.addprimary_entity = &i
	}
}

// AddedPrimaryEntity returns the value that was added to the "primary_entity" field in this mutation.
func (m *FileMutation) AddedPrimaryEntity() (r int, exists bool) {
	v := m.addprimary_entity
	if v == nil {
		return
	}
	return *v, true
}

// ClearPrimaryEntity clears the value of the "primary_entity" field.
func (m *FileMutation) ClearPrimaryEntity() {
	m.primary_entity = nil
	m.addprimary_entity = nil
	m.clearedFields[file.FieldPrimaryEntity] = struct{}{}
}

// PrimaryEntityCleared returns if the "primary_entity" field was cleared in this mutation.
func (m *FileMutation) PrimaryEntityCleared() bool {
	_, ok := m.clearedFields[file.FieldPrimaryEntity]
	return ok
}

// ResetPrimaryEntity resets all changes to the "primary_entity" field.
func (m *FileMutation) ResetPrimaryEntity() {
	m.primary_entity = nil
	m.addprimary_entity = nil
	delete(m.clearedFields, file.FieldPrimaryEntity)
}

// SetFileChildren sets the "file_children" field.
func (m *FileMutation) SetFileChildren(i int) {
	m.parent = &i
}

// FileChildren returns the value of the "file_children" field in the mutation.
func (m *FileMutation) FileChildren() (r int, exists bool) {
	v := m.parent
	if v == nil {
		return
	}
	return *v, true
}

// OldFileChildren returns the old "file_children" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldFileChildren(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFileChildren is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFileChildren requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFileChildren: %w", err)
	}
	return oldValue.FileChildren, nil
}

// ClearFileChildren clears the value of the "file_children" field.
func (m *FileMutation) ClearFileChildren() {
	m.parent = nil
	m.clearedFields[file.FieldFileChildren] = struct{}{}
}

// FileChildrenCleared returns if the "file_children" field was cleared in this mutation.
func (m *FileMutation) FileChildrenCleared() bool {
	_, ok := m.clearedFields[file.FieldFileChildren]
	return ok
}

// ResetFileChildren resets all changes to the "file_children" field.
func (m *FileMutation) ResetFileChildren() {
	m.parent = nil
	delete(m.clearedFields, file.FieldFileChildren)
}

// SetIsSymbolic sets the "is_symbolic" field.
func (m *FileMutation) SetIsSymbolic(b bool) {
	m.is_symbolic = &b
}

// IsSymbolic returns the value of the "is_symbolic" field in the mutation.
func (m *FileMutation) IsSymbolic() (r bool, exists bool) {
	v := m.is_symbolic
	if v == nil {
		return
	}
	return *v, true
}

// OldIsSymbolic returns the old "is_symbolic" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldIsSymbolic(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsSymbolic is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsSymbolic requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsSymbolic: %w", err)
	}
	return oldValue.IsSymbolic, nil
}

// ResetIsSymbolic resets all changes to the "is_symbolic" field.
func (m *FileMutation) ResetIsSymbolic() {
	m.is_symbolic = nil
}

// SetProps sets the "props" field.
func (m *FileMutation) SetProps(tp *types.FileProps) {
	m.props = &tp
}

// Props returns the value of the "props" field in the mutation.
func (m *FileMutation) Props() (r *types.FileProps, exists bool) {
	v := m.props
	if v == nil {
		return
	}
	return *v, true
}

// OldProps returns the old "props" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldProps(ctx context.Context) (v *types.FileProps, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProps is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProps requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProps: %w", err)
	}
	return oldValue.Props, nil
}

// ClearProps clears the value of the "props" field.
func (m *FileMutation) ClearProps() {
	m.props = nil
	m.clearedFields[file.FieldProps] = struct{}{}
}

// PropsCleared returns if the "props" field was cleared in this mutation.
func (m *FileMutation) PropsCleared() bool {
	_, ok := m.clearedFields[file.FieldProps]
	return ok
}

// ResetProps resets all changes to the "props" field.
func (m *FileMutation) ResetProps() {
	m.props = nil
	delete(m.clearedFields, file.FieldProps)
}

// SetStoragePolicyFiles sets the "storage_policy_files" field.
func (m *FileMutation) SetStoragePolicyFiles(i int) {
	m.storage_policies = &i
}

// StoragePolicyFiles returns the value of the "storage_policy_files" field in the mutation.
func (m *FileMutation) StoragePolicyFiles() (r int, exists bool) {
	v := m.storage_policies
	if v == nil {
		return
	}
	return *v, true
}

// OldStoragePolicyFiles returns the old "storage_policy_files" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldStoragePolicyFiles(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStoragePolicyFiles is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStoragePolicyFiles requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStoragePolicyFiles: %w", err)
	}
	return oldValue.StoragePolicyFiles, nil
}

// ClearStoragePolicyFiles clears the value of the "storage_policy_files" field.
func (m *FileMutation) ClearStoragePolicyFiles() {
	m.storage_policies = nil
	m.clearedFields[file.FieldStoragePolicyFiles] = struct{}{}
}

// StoragePolicyFilesCleared returns if the "storage_policy_files" field was cleared in this mutation.
func (m *FileMutation) StoragePolicyFilesCleared() bool {
	_, ok := m.clearedFields[file.FieldStoragePolicyFiles]
	return ok
}

// ResetStoragePolicyFiles resets all changes to the "storage_policy_files" field.
func (m *FileMutation) ResetStoragePolicyFiles() {
	m.storage_policies = nil
	delete(m.clearedFields, file.FieldStoragePolicyFiles)
}

// ClearOwner clears the "owner" edge to the User entity.
func (m *FileMutation) ClearOwner() {
	m.clearedowner = true
	m.clearedFields[file.FieldOwnerID] = struct{}{}
}

// OwnerCleared reports if the "owner" edge to the User entity was cleared.
func (m *FileMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *FileMutation) OwnerIDs() (ids []int) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *FileMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// SetStoragePoliciesID sets the "storage_policies" edge to the StoragePolicy entity by id.
func (m *FileMutation) SetStoragePoliciesID(id int) {
	m.storage_policies = &id
}

// ClearStoragePolicies clears the "storage_policies" edge to the StoragePolicy entity.
func (m *FileMutation) ClearStoragePolicies() {
	m.clearedstorage_policies = true
	m.clearedFields[file.FieldStoragePolicyFiles] = struct{}{}
}

// StoragePoliciesCleared reports if the "storage_policies" edge to the StoragePolicy entity was cleared.
func (m *FileMutation) StoragePoliciesCleared() bool {
	return m.StoragePolicyFilesCleared() || m.clearedstorage_policies
}

// StoragePoliciesID returns the "storage_policies" edge ID in the mutation.
func (m *FileMutation) StoragePoliciesID() (id int, exists bool) {
	if m.storage_policies != nil {
		return *m.storage_policies, true
	}
	return
}

// StoragePoliciesIDs returns the "storage_policies" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StoragePoliciesID instead. It exists only for internal usage by the builders.
func (m *FileMutation) StoragePoliciesIDs() (ids []int) {
	if id := m.storage_policies; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStoragePolicies resets all changes to the "storage_policies" edge.
func (m *FileMutation) ResetStoragePolicies() {
	m.storage_policies = nil
	m.clearedstorage_policies = false
}

// SetParentID sets the "parent" edge to the File entity by id.
func (m *FileMutation) SetParentID(id int) {
	m.parent = &id
}

// ClearParent clears the "parent" edge to the File entity.
func (m *FileMutation) ClearParent() {
	m.clearedparent = true
	m.clearedFields[file.FieldFileChildren] = struct{}{}
}

// ParentCleared reports if the "parent" edge to the File entity was cleared.
func (m *FileMutation) ParentCleared() bool {
	return m.FileChildrenCleared() || m.clearedparent
}

// ParentID returns the "parent" edge ID in the mutation.
func (m *FileMutation) ParentID() (id int, exists bool) {
	if m.parent != nil {
		return *m.parent, true
	}
	return
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *FileMutation) ParentIDs() (ids []int) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *FileMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddChildIDs adds the "children" edge to the File entity by ids.
func (m *FileMutation) AddChildIDs(ids ...int) {
	if m.children == nil {
		m.children = make(map[int]struct{})
	}
	for i := range ids {
		m.children[ids[i]] = struct{}{}
	}
}

// ClearChildren clears the "children" edge to the File entity.
func (m *FileMutation) ClearChildren() {
	m.clearedchildren = true
}

// ChildrenCleared reports if the "children" edge to the File entity was cleared.
func (m *FileMutation) ChildrenCleared() bool {
	return m.clearedchildren
}

// RemoveChildIDs removes the "children" edge to the File entity by IDs.
func (m *FileMutation) RemoveChildIDs(ids ...int) {
	if m.removedchildren == nil {
		m.removedchildren = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.children, ids[i])
		m.removedchildren[ids[i]] = struct{}{}
	}
}

// RemovedChildren returns the removed IDs of the "children" edge to the File entity.
func (m *FileMutation) RemovedChildrenIDs() (ids []int) {
	for id := range m.removedchildren {
		ids = append(ids, id)
	}
	return
}

// ChildrenIDs returns the "children" edge IDs in the mutation.
func (m *FileMutation) ChildrenIDs() (ids []int) {
	for id := range m.children {
		ids = append(ids, id)
	}
	return
}

// ResetChildren resets all changes to the "children" edge.
func (m *FileMutation) ResetChildren() {
	m.children = nil
	m.clearedchildren = false
	m.removedchildren = nil
}

// AddMetadatumIDs adds the "metadata" edge to the Metadata entity by ids.
func (m *FileMutation) AddMetadatumIDs(ids ...int) {
	if m.metadata == nil {
		m.metadata = make(map[int]struct{})
	}
	for i := range ids {
		m.metadata[ids[i]] = struct{}{}
	}
}

// ClearMetadata clears the "metadata" edge to the Metadata entity.
func (m *FileMutation) ClearMetadata() {
	m.clearedmetadata = true
}

// MetadataCleared reports if the "metadata" edge to the Metadata entity was cleared.
func (m *FileMutation) MetadataCleared() bool {
	return m.clearedmetadata
}

// RemoveMetadatumIDs removes the "metadata" edge to the Metadata entity by IDs.
func (m *FileMutation) RemoveMetadatumIDs(ids ...int) {
	if m.removedmetadata == nil {
		m.removedmetadata = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.metadata, ids[i])
		m.removedmetadata[ids[i]] = struct{}{}
	}
}

// RemovedMetadata returns the removed IDs of the "metadata" edge to the Metadata entity.
func (m *FileMutation) RemovedMetadataIDs() (ids []int) {
	for id := range m.removedmetadata {
		ids = append(ids, id)
	}
	return
}

// MetadataIDs returns the "metadata" edge IDs in the mutation.
func (m *FileMutation) MetadataIDs() (ids []int) {
	for id := range m.metadata {
		ids = append(ids, id)
	}
	return
}

// ResetMetadata resets all changes to the "metadata" edge.
func (m *FileMutation) ResetMetadata() {
	m.metadata = nil
	m.clearedmetadata = false
	m.removedmetadata = nil
}

// AddEntityIDs adds the "entities" edge to the Entity entity by ids.
func (m *FileMutation) AddEntityIDs(ids ...int) {
	if m.entities == nil {
		m.entities = make(map[int]struct{})
	}
	for i := range ids {
		m.entities[ids[i]] = struct{}{}
	}
}

// ClearEntities clears the "entities" edge to the Entity entity.
func (m *FileMutation) ClearEntities() {
	m.clearedentities = true
}

// EntitiesCleared reports if the "entities" edge to the Entity entity was cleared.
func (m *FileMutation) EntitiesCleared() bool {
	return m.clearedentities
}

// RemoveEntityIDs removes the "entities" edge to the Entity entity by IDs.
func (m *FileMutation) RemoveEntityIDs(ids ...int) {
	if m.removedentities == nil {
		m.removedentities = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.entities, ids[i])
		m.removedentities[ids[i]] = struct{}{}
	}
}

// RemovedEntities returns the removed IDs of the "entities" edge to the Entity entity.
func (m *FileMutation) RemovedEntitiesIDs() (ids []int) {
	for id := range m.removedentities {
		ids = append(ids, id)
	}
	return
}

// EntitiesIDs returns the "entities" edge IDs in the mutation.
func (m *FileMutation) EntitiesIDs() (ids []int) {
	for id := range m.entities {
		ids = append(ids, id)
	}
	return
}

// ResetEntities resets all changes to the "entities" edge.
func (m *FileMutation) ResetEntities() {
	m.entities = nil
	m.clearedentities = false
	m.removedentities = nil
}

// AddShareIDs adds the "shares" edge to the Share entity by ids.
func (m *FileMutation) AddShareIDs(ids ...int) {
	if m.shares == nil {
		m.shares = make(map[int]struct{})
	}
	for i := range ids {
		m.shares[ids[i]] = struct{}{}
	}
}

// ClearShares clears the "shares" edge to the Share entity.
func (m *FileMutation) ClearShares() {
	m.clearedshares = true
}

// SharesCleared reports if the "shares" edge to the Share entity was cleared.
func (m *FileMutation) SharesCleared() bool {
	return m.clearedshares
}

// RemoveShareIDs removes the "shares" edge to the Share entity by IDs.
func (m *FileMutation) RemoveShareIDs(ids ...int) {
	if m.removedshares == nil {
		m.removedshares = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.shares, ids[i])
		m.removedshares[ids[i]] = struct{}{}
	}
}

// RemovedShares returns the removed IDs of the "shares" edge to the Share entity.
func (m *FileMutation) RemovedSharesIDs() (ids []int) {
	for id := range m.removedshares {
		ids = append(ids, id)
	}
	return
}

// SharesIDs returns the "shares" edge IDs in the mutation.
func (m *FileMutation) SharesIDs() (ids []int) {
	for id := range m.shares {
		ids = append(ids, id)
	}
	return
}

// ResetShares resets all changes to the "shares" edge.
func (m *FileMutation) ResetShares() {
	m.shares = nil
	m.clearedshares = false
	m.removedshares = nil
}

// AddDirectLinkIDs adds the "direct_links" edge to the DirectLink entity by ids.
func (m *FileMutation) AddDirectLinkIDs(ids ...int) {
	if m.direct_links == nil {
		m.direct_links = make(map[int]struct{})
	}
	for i := range ids {
		m.direct_links[ids[i]] = struct{}{}
	}
}

// ClearDirectLinks clears the "direct_links" edge to the DirectLink entity.
func (m *FileMutation) ClearDirectLinks() {
	m.cleareddirect_links = true
}

// DirectLinksCleared reports if the "direct_links" edge to the DirectLink entity was cleared.
func (m *FileMutation) DirectLinksCleared() bool {
	return m.cleareddirect_links
}

// RemoveDirectLinkIDs removes the "direct_links" edge to the DirectLink entity by IDs.
func (m *FileMutation) RemoveDirectLinkIDs(ids ...int) {
	if m.removeddirect_links == nil {
		m.removeddirect_links = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.direct_links, ids[i])
		m.removeddirect_links[ids[i]] = struct{}{}
	}
}

// RemovedDirectLinks returns the removed IDs of the "direct_links" edge to the DirectLink entity.
func (m *FileMutation) RemovedDirectLinksIDs() (ids []int) {
	for id := range m.removeddirect_links {
		ids = append(ids, id)
	}
	return
}

// DirectLinksIDs returns the "direct_links" edge IDs in the mutation.
func (m *FileMutation) DirectLinksIDs() (ids []int) {
	for id := range m.direct_links {
		ids = append(ids, id)
	}
	return
}

// ResetDirectLinks resets all changes to the "direct_links" edge.
func (m *FileMutation) ResetDirectLinks() {
	m.direct_links = nil
	m.cleareddirect_links = false
	m.removeddirect_links = nil
}

// Where appends a list predicates to the FileMutation builder.
func (m *FileMutation) Where(ps ...predicate.File) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FileMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FileMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.File, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FileMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FileMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (File).
func (m *FileMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FileMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.created_at != nil {
		fields = append(fields, file.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, file.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, file.FieldDeletedAt)
	}
	if m._type != nil {
		fields = append(fields, file.FieldType)
	}
	if m.name != nil {
		fields = append(fields, file.FieldName)
	}
	if m.owner != nil {
		fields = append(fields, file.FieldOwnerID)
	}
	if m.size != nil {
		fields = append(fields, file.FieldSize)
	}
	if m.primary_entity != nil {
		fields = append(fields, file.FieldPrimaryEntity)
	}
	if m.parent != nil {
		fields = append(fields, file.FieldFileChildren)
	}
	if m.is_symbolic != nil {
		fields = append(fields, file.FieldIsSymbolic)
	}
	if m.props != nil {
		fields = append(fields, file.FieldProps)
	}
	if m.storage_policies != nil {
		fields = append(fields, file.FieldStoragePolicyFiles)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FileMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case file.FieldCreatedAt:
		return m.CreatedAt()
	case file.FieldUpdatedAt:
		return m.UpdatedAt()
	case file.FieldDeletedAt:
		return m.DeletedAt()
	case file.FieldType:
		return m.GetType()
	case file.FieldName:
		return m.Name()
	case file.FieldOwnerID:
		return m.OwnerID()
	case file.FieldSize:
		return m.Size()
	case file.FieldPrimaryEntity:
		return m.PrimaryEntity()
	case file.FieldFileChildren:
		return m.FileChildren()
	case file.FieldIsSymbolic:
		return m.IsSymbolic()
	case file.FieldProps:
		return m.Props()
	case file.FieldStoragePolicyFiles:
		return m.StoragePolicyFiles()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FileMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case file.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case file.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case file.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case file.FieldType:
		return m.OldType(ctx)
	case file.FieldName:
		return m.OldName(ctx)
	case file.FieldOwnerID:
		return m.OldOwnerID(ctx)
	case file.FieldSize:
		return m.OldSize(ctx)
	case file.FieldPrimaryEntity:
		return m.OldPrimaryEntity(ctx)
	case file.FieldFileChildren:
		return m.OldFileChildren(ctx)
	case file.FieldIsSymbolic:
		return m.OldIsSymbolic(ctx)
	case file.FieldProps:
		return m.OldProps(ctx)
	case file.FieldStoragePolicyFiles:
		return m.OldStoragePolicyFiles(ctx)
	}
	return nil, fmt.Errorf("unknown File field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FileMutation) SetField(name string, value ent.Value) error {
	switch name {
	case file.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case file.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case file.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case file.FieldType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case file.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case file.FieldOwnerID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerID(v)
		return nil
	case file.FieldSize:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSize(v)
		return nil
	case file.FieldPrimaryEntity:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrimaryEntity(v)
		return nil
	case file.FieldFileChildren:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFileChildren(v)
		return nil
	case file.FieldIsSymbolic:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsSymbolic(v)
		return nil
	case file.FieldProps:
		v, ok := value.(*types.FileProps)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProps(v)
		return nil
	case file.FieldStoragePolicyFiles:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStoragePolicyFiles(v)
		return nil
	}
	return fmt.Errorf("unknown File field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FileMutation) AddedFields() []string {
	var fields []string
	if m.add_type != nil {
		fields = append(fields, file.FieldType)
	}
	if m.addsize != nil {
		fields = append(fields, file.FieldSize)
	}
	if m.addprimary_entity != nil {
		fields = append(fields, file.FieldPrimaryEntity)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FileMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case file.FieldType:
		return m.AddedType()
	case file.FieldSize:
		return m.AddedSize()
	case file.FieldPrimaryEntity:
		return m.AddedPrimaryEntity()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FileMutation) AddField(name string, value ent.Value) error {
	switch name {
	case file.FieldType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddType(v)
		return nil
	case file.FieldSize:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSize(v)
		return nil
	case file.FieldPrimaryEntity:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPrimaryEntity(v)
		return nil
	}
	return fmt.Errorf("unknown File numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FileMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(file.FieldDeletedAt) {
		fields = append(fields, file.FieldDeletedAt)
	}
	if m.FieldCleared(file.FieldPrimaryEntity) {
		fields = append(fields, file.FieldPrimaryEntity)
	}
	if m.FieldCleared(file.FieldFileChildren) {
		fields = append(fields, file.FieldFileChildren)
	}
	if m.FieldCleared(file.FieldProps) {
		fields = append(fields, file.FieldProps)
	}
	if m.FieldCleared(file.FieldStoragePolicyFiles) {
		fields = append(fields, file.FieldStoragePolicyFiles)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FileMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FileMutation) ClearField(name string) error {
	switch name {
	case file.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case file.FieldPrimaryEntity:
		m.ClearPrimaryEntity()
		return nil
	case file.FieldFileChildren:
		m.ClearFileChildren()
		return nil
	case file.FieldProps:
		m.ClearProps()
		return nil
	case file.FieldStoragePolicyFiles:
		m.ClearStoragePolicyFiles()
		return nil
	}
	return fmt.Errorf("unknown File nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FileMutation) ResetField(name string) error {
	switch name {
	case file.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case file.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case file.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case file.FieldType:
		m.ResetType()
		return nil
	case file.FieldName:
		m.ResetName()
		return nil
	case file.FieldOwnerID:
		m.ResetOwnerID()
		return nil
	case file.FieldSize:
		m.ResetSize()
		return nil
	case file.FieldPrimaryEntity:
		m.ResetPrimaryEntity()
		return nil
	case file.FieldFileChildren:
		m.ResetFileChildren()
		return nil
	case file.FieldIsSymbolic:
		m.ResetIsSymbolic()
		return nil
	case file.FieldProps:
		m.ResetProps()
		return nil
	case file.FieldStoragePolicyFiles:
		m.ResetStoragePolicyFiles()
		return nil
	}
	return fmt.Errorf("unknown File field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FileMutation) AddedEdges() []string {
	edges := make([]string, 0, 8)
	if m.owner != nil {
		edges = append(edges, file.EdgeOwner)
	}
	if m.storage_policies != nil {
		edges = append(edges, file.EdgeStoragePolicies)
	}
	if m.parent != nil {
		edges = append(edges, file.EdgeParent)
	}
	if m.children != nil {
		edges = append(edges, file.EdgeChildren)
	}
	if m.metadata != nil {
		edges = append(edges, file.EdgeMetadata)
	}
	if m.entities != nil {
		edges = append(edges, file.EdgeEntities)
	}
	if m.shares != nil {
		edges = append(edges, file.EdgeShares)
	}
	if m.direct_links != nil {
		edges = append(edges, file.EdgeDirectLinks)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FileMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case file.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	case file.EdgeStoragePolicies:
		if id := m.storage_policies; id != nil {
			return []ent.Value{*id}
		}
	case file.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case file.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.children))
		for id := range m.children {
			ids = append(ids, id)
		}
		return ids
	case file.EdgeMetadata:
		ids := make([]ent.Value, 0, len(m.metadata))
		for id := range m.metadata {
			ids = append(ids, id)
		}
		return ids
	case file.EdgeEntities:
		ids := make([]ent.Value, 0, len(m.entities))
		for id := range m.entities {
			ids = append(ids, id)
		}
		return ids
	case file.EdgeShares:
		ids := make([]ent.Value, 0, len(m.shares))
		for id := range m.shares {
			ids = append(ids, id)
		}
		return ids
	case file.EdgeDirectLinks:
		ids := make([]ent.Value, 0, len(m.direct_links))
		for id := range m.direct_links {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FileMutation) RemovedEdges() []string {
	edges := make([]string, 0, 8)
	if m.removedchildren != nil {
		edges = append(edges, file.EdgeChildren)
	}
	if m.removedmetadata != nil {
		edges = append(edges, file.EdgeMetadata)
	}
	if m.removedentities != nil {
		edges = append(edges, file.EdgeEntities)
	}
	if m.removedshares != nil {
		edges = append(edges, file.EdgeShares)
	}
	if m.removeddirect_links != nil {
		edges = append(edges, file.EdgeDirectLinks)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FileMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case file.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.removedchildren))
		for id := range m.removedchildren {
			ids = append(ids, id)
		}
		return ids
	case file.EdgeMetadata:
		ids := make([]ent.Value, 0, len(m.removedmetadata))
		for id := range m.removedmetadata {
			ids = append(ids, id)
		}
		return ids
	case file.EdgeEntities:
		ids := make([]ent.Value, 0, len(m.removedentities))
		for id := range m.removedentities {
			ids = append(ids, id)
		}
		return ids
	case file.EdgeShares:
		ids := make([]ent.Value, 0, len(m.removedshares))
		for id := range m.removedshares {
			ids = append(ids, id)
		}
		return ids
	case file.EdgeDirectLinks:
		ids := make([]ent.Value, 0, len(m.removeddirect_links))
		for id := range m.removeddirect_links {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FileMutation) ClearedEdges() []string {
	edges := make([]string, 0, 8)
	if m.clearedowner {
		edges = append(edges, file.EdgeOwner)
	}
	if m.clearedstorage_policies {
		edges = append(edges, file.EdgeStoragePolicies)
	}
	if m.clearedparent {
		edges = append(edges, file.EdgeParent)
	}
	if m.clearedchildren {
		edges = append(edges, file.EdgeChildren)
	}
	if m.clearedmetadata {
		edges = append(edges, file.EdgeMetadata)
	}
	if m.clearedentities {
		edges = append(edges, file.EdgeEntities)
	}
	if m.clearedshares {
		edges = append(edges, file.EdgeShares)
	}
	if m.cleareddirect_links {
		edges = append(edges, file.EdgeDirectLinks)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FileMutation) EdgeCleared(name string) bool {
	switch name {
	case file.EdgeOwner:
		return m.clearedowner
	case file.EdgeStoragePolicies:
		return m.clearedstorage_policies
	case file.EdgeParent:
		return m.clearedparent
	case file.EdgeChildren:
		return m.clearedchildren
	case file.EdgeMetadata:
		return m.clearedmetadata
	case file.EdgeEntities:
		return m.clearedentities
	case file.EdgeShares:
		return m.clearedshares
	case file.EdgeDirectLinks:
		return m.cleareddirect_links
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FileMutation) ClearEdge(name string) error {
	switch name {
	case file.EdgeOwner:
		m.ClearOwner()
		return nil
	case file.EdgeStoragePolicies:
		m.ClearStoragePolicies()
		return nil
	case file.EdgeParent:
		m.ClearParent()
		return nil
	}
	return fmt.Errorf("unknown File unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FileMutation) ResetEdge(name string) error {
	switch name {
	case file.EdgeOwner:
		m.ResetOwner()
		return nil
	case file.EdgeStoragePolicies:
		m.ResetStoragePolicies()
		return nil
	case file.EdgeParent:
		m.ResetParent()
		return nil
	case file.EdgeChildren:
		m.ResetChildren()
		return nil
	case file.EdgeMetadata:
		m.ResetMetadata()
		return nil
	case file.EdgeEntities:
		m.ResetEntities()
		return nil
	case file.EdgeShares:
		m.ResetShares()
		return nil
	case file.EdgeDirectLinks:
		m.ResetDirectLinks()
		return nil
	}
	return fmt.Errorf("unknown File edge %s", name)
}

// GroupMutation represents an operation that mutates the Group nodes in the graph.
type GroupMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int
	created_at              *time.Time
	updated_at              *time.Time
	deleted_at              *time.Time
	name                    *string
	max_storage             *int64
	addmax_storage          *int64
	speed_limit             *int
	addspeed_limit          *int
	permissions             **boolset.BooleanSet
	settings                **types.GroupSetting
	clearedFields           map[string]struct{}
	users                   map[int]struct{}
	removedusers            map[int]struct{}
	clearedusers            bool
	storage_policies        *int
	clearedstorage_policies bool
	done                    bool
	oldValue                func(context.Context) (*Group, error)
	predicates              []predicate.Group
}

var _ ent.Mutation = (*GroupMutation)(nil)

// groupOption allows management of the mutation configuration using functional options.
type groupOption func(*GroupMutation)

// newGroupMutation creates new mutation for the Group entity.
func newGroupMutation(c config, op Op, opts ...groupOption) *GroupMutation {
	m := &GroupMutation{
		config:        c,
		op:            op,
		typ:           TypeGroup,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGroupID sets the ID field of the mutation.
func withGroupID(id int) groupOption {
	return func(m *GroupMutation) {
		var (
			err   error
			once  sync.Once
			value *Group
		)
		m.oldValue = func(ctx context.Context) (*Group, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Group.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGroup sets the old Group of the mutation.
func withGroup(node *Group) groupOption {
	return func(m *GroupMutation) {
		m.oldValue = func(context.Context) (*Group, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GroupMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GroupMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GroupMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GroupMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Group.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *GroupMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *GroupMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Group entity.
// If the Group object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *GroupMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *GroupMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *GroupMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Group entity.
// If the Group object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *GroupMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *GroupMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *GroupMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Group entity.
// If the Group object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *GroupMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[group.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *GroupMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[group.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *GroupMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, group.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *GroupMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *GroupMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Group entity.
// If the Group object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *GroupMutation) ResetName() {
	m.name = nil
}

// SetMaxStorage sets the "max_storage" field.
func (m *GroupMutation) SetMaxStorage(i int64) {
	m.max_storage = &i
	m.addmax_storage = nil
}

// MaxStorage returns the value of the "max_storage" field in the mutation.
func (m *GroupMutation) MaxStorage() (r int64, exists bool) {
	v := m.max_storage
	if v == nil {
		return
	}
	return *v, true
}

// OldMaxStorage returns the old "max_storage" field's value of the Group entity.
// If the Group object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMutation) OldMaxStorage(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaxStorage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaxStorage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaxStorage: %w", err)
	}
	return oldValue.MaxStorage, nil
}

// AddMaxStorage adds i to the "max_storage" field.
func (m *GroupMutation) AddMaxStorage(i int64) {
	if m.addmax_storage != nil {
		*m.addmax_storage += i
	} else {
		m.addmax_storage = &i
	}
}

// AddedMaxStorage returns the value that was added to the "max_storage" field in this mutation.
func (m *GroupMutation) AddedMaxStorage() (r int64, exists bool) {
	v := m.addmax_storage
	if v == nil {
		return
	}
	return *v, true
}

// ClearMaxStorage clears the value of the "max_storage" field.
func (m *GroupMutation) ClearMaxStorage() {
	m.max_storage = nil
	m.addmax_storage = nil
	m.clearedFields[group.FieldMaxStorage] = struct{}{}
}

// MaxStorageCleared returns if the "max_storage" field was cleared in this mutation.
func (m *GroupMutation) MaxStorageCleared() bool {
	_, ok := m.clearedFields[group.FieldMaxStorage]
	return ok
}

// ResetMaxStorage resets all changes to the "max_storage" field.
func (m *GroupMutation) ResetMaxStorage() {
	m.max_storage = nil
	m.addmax_storage = nil
	delete(m.clearedFields, group.FieldMaxStorage)
}

// SetSpeedLimit sets the "speed_limit" field.
func (m *GroupMutation) SetSpeedLimit(i int) {
	m.speed_limit = &i
	m.addspeed_limit = nil
}

// SpeedLimit returns the value of the "speed_limit" field in the mutation.
func (m *GroupMutation) SpeedLimit() (r int, exists bool) {
	v := m.speed_limit
	if v == nil {
		return
	}
	return *v, true
}

// OldSpeedLimit returns the old "speed_limit" field's value of the Group entity.
// If the Group object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMutation) OldSpeedLimit(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSpeedLimit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSpeedLimit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpeedLimit: %w", err)
	}
	return oldValue.SpeedLimit, nil
}

// AddSpeedLimit adds i to the "speed_limit" field.
func (m *GroupMutation) AddSpeedLimit(i int) {
	if m.addspeed_limit != nil {
		*m.addspeed_limit += i
	} else {
		m.addspeed_limit = &i
	}
}

// AddedSpeedLimit returns the value that was added to the "speed_limit" field in this mutation.
func (m *GroupMutation) AddedSpeedLimit() (r int, exists bool) {
	v := m.addspeed_limit
	if v == nil {
		return
	}
	return *v, true
}

// ClearSpeedLimit clears the value of the "speed_limit" field.
func (m *GroupMutation) ClearSpeedLimit() {
	m.speed_limit = nil
	m.addspeed_limit = nil
	m.clearedFields[group.FieldSpeedLimit] = struct{}{}
}

// SpeedLimitCleared returns if the "speed_limit" field was cleared in this mutation.
func (m *GroupMutation) SpeedLimitCleared() bool {
	_, ok := m.clearedFields[group.FieldSpeedLimit]
	return ok
}

// ResetSpeedLimit resets all changes to the "speed_limit" field.
func (m *GroupMutation) ResetSpeedLimit() {
	m.speed_limit = nil
	m.addspeed_limit = nil
	delete(m.clearedFields, group.FieldSpeedLimit)
}

// SetPermissions sets the "permissions" field.
func (m *GroupMutation) SetPermissions(bs *boolset.BooleanSet) {
	m.permissions = &bs
}

// Permissions returns the value of the "permissions" field in the mutation.
func (m *GroupMutation) Permissions() (r *boolset.BooleanSet, exists bool) {
	v := m.permissions
	if v == nil {
		return
	}
	return *v, true
}

// OldPermissions returns the old "permissions" field's value of the Group entity.
// If the Group object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMutation) OldPermissions(ctx context.Context) (v *boolset.BooleanSet, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPermissions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPermissions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPermissions: %w", err)
	}
	return oldValue.Permissions, nil
}

// ResetPermissions resets all changes to the "permissions" field.
func (m *GroupMutation) ResetPermissions() {
	m.permissions = nil
}

// SetSettings sets the "settings" field.
func (m *GroupMutation) SetSettings(ts *types.GroupSetting) {
	m.settings = &ts
}

// Settings returns the value of the "settings" field in the mutation.
func (m *GroupMutation) Settings() (r *types.GroupSetting, exists bool) {
	v := m.settings
	if v == nil {
		return
	}
	return *v, true
}

// OldSettings returns the old "settings" field's value of the Group entity.
// If the Group object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMutation) OldSettings(ctx context.Context) (v *types.GroupSetting, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSettings is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSettings requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSettings: %w", err)
	}
	return oldValue.Settings, nil
}

// ClearSettings clears the value of the "settings" field.
func (m *GroupMutation) ClearSettings() {
	m.settings = nil
	m.clearedFields[group.FieldSettings] = struct{}{}
}

// SettingsCleared returns if the "settings" field was cleared in this mutation.
func (m *GroupMutation) SettingsCleared() bool {
	_, ok := m.clearedFields[group.FieldSettings]
	return ok
}

// ResetSettings resets all changes to the "settings" field.
func (m *GroupMutation) ResetSettings() {
	m.settings = nil
	delete(m.clearedFields, group.FieldSettings)
}

// SetStoragePolicyID sets the "storage_policy_id" field.
func (m *GroupMutation) SetStoragePolicyID(i int) {
	m.storage_policies = &i
}

// StoragePolicyID returns the value of the "storage_policy_id" field in the mutation.
func (m *GroupMutation) StoragePolicyID() (r int, exists bool) {
	v := m.storage_policies
	if v == nil {
		return
	}
	return *v, true
}

// OldStoragePolicyID returns the old "storage_policy_id" field's value of the Group entity.
// If the Group object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMutation) OldStoragePolicyID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStoragePolicyID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStoragePolicyID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStoragePolicyID: %w", err)
	}
	return oldValue.StoragePolicyID, nil
}

// ClearStoragePolicyID clears the value of the "storage_policy_id" field.
func (m *GroupMutation) ClearStoragePolicyID() {
	m.storage_policies = nil
	m.clearedFields[group.FieldStoragePolicyID] = struct{}{}
}

// StoragePolicyIDCleared returns if the "storage_policy_id" field was cleared in this mutation.
func (m *GroupMutation) StoragePolicyIDCleared() bool {
	_, ok := m.clearedFields[group.FieldStoragePolicyID]
	return ok
}

// ResetStoragePolicyID resets all changes to the "storage_policy_id" field.
func (m *GroupMutation) ResetStoragePolicyID() {
	m.storage_policies = nil
	delete(m.clearedFields, group.FieldStoragePolicyID)
}

// AddUserIDs adds the "users" edge to the User entity by ids.
func (m *GroupMutation) AddUserIDs(ids ...int) {
	if m.users == nil {
		m.users = make(map[int]struct{})
	}
	for i := range ids {
		m.users[ids[i]] = struct{}{}
	}
}

// ClearUsers clears the "users" edge to the User entity.
func (m *GroupMutation) ClearUsers() {
	m.clearedusers = true
}

// UsersCleared reports if the "users" edge to the User entity was cleared.
func (m *GroupMutation) UsersCleared() bool {
	return m.clearedusers
}

// RemoveUserIDs removes the "users" edge to the User entity by IDs.
func (m *GroupMutation) RemoveUserIDs(ids ...int) {
	if m.removedusers == nil {
		m.removedusers = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.users, ids[i])
		m.removedusers[ids[i]] = struct{}{}
	}
}

// RemovedUsers returns the removed IDs of the "users" edge to the User entity.
func (m *GroupMutation) RemovedUsersIDs() (ids []int) {
	for id := range m.removedusers {
		ids = append(ids, id)
	}
	return
}

// UsersIDs returns the "users" edge IDs in the mutation.
func (m *GroupMutation) UsersIDs() (ids []int) {
	for id := range m.users {
		ids = append(ids, id)
	}
	return
}

// ResetUsers resets all changes to the "users" edge.
func (m *GroupMutation) ResetUsers() {
	m.users = nil
	m.clearedusers = false
	m.removedusers = nil
}

// SetStoragePoliciesID sets the "storage_policies" edge to the StoragePolicy entity by id.
func (m *GroupMutation) SetStoragePoliciesID(id int) {
	m.storage_policies = &id
}

// ClearStoragePolicies clears the "storage_policies" edge to the StoragePolicy entity.
func (m *GroupMutation) ClearStoragePolicies() {
	m.clearedstorage_policies = true
	m.clearedFields[group.FieldStoragePolicyID] = struct{}{}
}

// StoragePoliciesCleared reports if the "storage_policies" edge to the StoragePolicy entity was cleared.
func (m *GroupMutation) StoragePoliciesCleared() bool {
	return m.StoragePolicyIDCleared() || m.clearedstorage_policies
}

// StoragePoliciesID returns the "storage_policies" edge ID in the mutation.
func (m *GroupMutation) StoragePoliciesID() (id int, exists bool) {
	if m.storage_policies != nil {
		return *m.storage_policies, true
	}
	return
}

// StoragePoliciesIDs returns the "storage_policies" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StoragePoliciesID instead. It exists only for internal usage by the builders.
func (m *GroupMutation) StoragePoliciesIDs() (ids []int) {
	if id := m.storage_policies; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStoragePolicies resets all changes to the "storage_policies" edge.
func (m *GroupMutation) ResetStoragePolicies() {
	m.storage_policies = nil
	m.clearedstorage_policies = false
}

// Where appends a list predicates to the GroupMutation builder.
func (m *GroupMutation) Where(ps ...predicate.Group) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the GroupMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *GroupMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Group, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *GroupMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *GroupMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Group).
func (m *GroupMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GroupMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, group.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, group.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, group.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, group.FieldName)
	}
	if m.max_storage != nil {
		fields = append(fields, group.FieldMaxStorage)
	}
	if m.speed_limit != nil {
		fields = append(fields, group.FieldSpeedLimit)
	}
	if m.permissions != nil {
		fields = append(fields, group.FieldPermissions)
	}
	if m.settings != nil {
		fields = append(fields, group.FieldSettings)
	}
	if m.storage_policies != nil {
		fields = append(fields, group.FieldStoragePolicyID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GroupMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case group.FieldCreatedAt:
		return m.CreatedAt()
	case group.FieldUpdatedAt:
		return m.UpdatedAt()
	case group.FieldDeletedAt:
		return m.DeletedAt()
	case group.FieldName:
		return m.Name()
	case group.FieldMaxStorage:
		return m.MaxStorage()
	case group.FieldSpeedLimit:
		return m.SpeedLimit()
	case group.FieldPermissions:
		return m.Permissions()
	case group.FieldSettings:
		return m.Settings()
	case group.FieldStoragePolicyID:
		return m.StoragePolicyID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GroupMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case group.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case group.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case group.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case group.FieldName:
		return m.OldName(ctx)
	case group.FieldMaxStorage:
		return m.OldMaxStorage(ctx)
	case group.FieldSpeedLimit:
		return m.OldSpeedLimit(ctx)
	case group.FieldPermissions:
		return m.OldPermissions(ctx)
	case group.FieldSettings:
		return m.OldSettings(ctx)
	case group.FieldStoragePolicyID:
		return m.OldStoragePolicyID(ctx)
	}
	return nil, fmt.Errorf("unknown Group field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GroupMutation) SetField(name string, value ent.Value) error {
	switch name {
	case group.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case group.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case group.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case group.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case group.FieldMaxStorage:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaxStorage(v)
		return nil
	case group.FieldSpeedLimit:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpeedLimit(v)
		return nil
	case group.FieldPermissions:
		v, ok := value.(*boolset.BooleanSet)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPermissions(v)
		return nil
	case group.FieldSettings:
		v, ok := value.(*types.GroupSetting)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSettings(v)
		return nil
	case group.FieldStoragePolicyID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStoragePolicyID(v)
		return nil
	}
	return fmt.Errorf("unknown Group field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GroupMutation) AddedFields() []string {
	var fields []string
	if m.addmax_storage != nil {
		fields = append(fields, group.FieldMaxStorage)
	}
	if m.addspeed_limit != nil {
		fields = append(fields, group.FieldSpeedLimit)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GroupMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case group.FieldMaxStorage:
		return m.AddedMaxStorage()
	case group.FieldSpeedLimit:
		return m.AddedSpeedLimit()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GroupMutation) AddField(name string, value ent.Value) error {
	switch name {
	case group.FieldMaxStorage:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaxStorage(v)
		return nil
	case group.FieldSpeedLimit:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSpeedLimit(v)
		return nil
	}
	return fmt.Errorf("unknown Group numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GroupMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(group.FieldDeletedAt) {
		fields = append(fields, group.FieldDeletedAt)
	}
	if m.FieldCleared(group.FieldMaxStorage) {
		fields = append(fields, group.FieldMaxStorage)
	}
	if m.FieldCleared(group.FieldSpeedLimit) {
		fields = append(fields, group.FieldSpeedLimit)
	}
	if m.FieldCleared(group.FieldSettings) {
		fields = append(fields, group.FieldSettings)
	}
	if m.FieldCleared(group.FieldStoragePolicyID) {
		fields = append(fields, group.FieldStoragePolicyID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GroupMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GroupMutation) ClearField(name string) error {
	switch name {
	case group.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case group.FieldMaxStorage:
		m.ClearMaxStorage()
		return nil
	case group.FieldSpeedLimit:
		m.ClearSpeedLimit()
		return nil
	case group.FieldSettings:
		m.ClearSettings()
		return nil
	case group.FieldStoragePolicyID:
		m.ClearStoragePolicyID()
		return nil
	}
	return fmt.Errorf("unknown Group nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GroupMutation) ResetField(name string) error {
	switch name {
	case group.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case group.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case group.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case group.FieldName:
		m.ResetName()
		return nil
	case group.FieldMaxStorage:
		m.ResetMaxStorage()
		return nil
	case group.FieldSpeedLimit:
		m.ResetSpeedLimit()
		return nil
	case group.FieldPermissions:
		m.ResetPermissions()
		return nil
	case group.FieldSettings:
		m.ResetSettings()
		return nil
	case group.FieldStoragePolicyID:
		m.ResetStoragePolicyID()
		return nil
	}
	return fmt.Errorf("unknown Group field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GroupMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.users != nil {
		edges = append(edges, group.EdgeUsers)
	}
	if m.storage_policies != nil {
		edges = append(edges, group.EdgeStoragePolicies)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GroupMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case group.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.users))
		for id := range m.users {
			ids = append(ids, id)
		}
		return ids
	case group.EdgeStoragePolicies:
		if id := m.storage_policies; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GroupMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedusers != nil {
		edges = append(edges, group.EdgeUsers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GroupMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case group.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.removedusers))
		for id := range m.removedusers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GroupMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedusers {
		edges = append(edges, group.EdgeUsers)
	}
	if m.clearedstorage_policies {
		edges = append(edges, group.EdgeStoragePolicies)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GroupMutation) EdgeCleared(name string) bool {
	switch name {
	case group.EdgeUsers:
		return m.clearedusers
	case group.EdgeStoragePolicies:
		return m.clearedstorage_policies
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GroupMutation) ClearEdge(name string) error {
	switch name {
	case group.EdgeStoragePolicies:
		m.ClearStoragePolicies()
		return nil
	}
	return fmt.Errorf("unknown Group unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GroupMutation) ResetEdge(name string) error {
	switch name {
	case group.EdgeUsers:
		m.ResetUsers()
		return nil
	case group.EdgeStoragePolicies:
		m.ResetStoragePolicies()
		return nil
	}
	return fmt.Errorf("unknown Group edge %s", name)
}

// MetadataMutation represents an operation that mutates the Metadata nodes in the graph.
type MetadataMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	name          *string
	value         *string
	is_public     *bool
	clearedFields map[string]struct{}
	file          *int
	clearedfile   bool
	done          bool
	oldValue      func(context.Context) (*Metadata, error)
	predicates    []predicate.Metadata
}

var _ ent.Mutation = (*MetadataMutation)(nil)

// metadataOption allows management of the mutation configuration using functional options.
type metadataOption func(*MetadataMutation)

// newMetadataMutation creates new mutation for the Metadata entity.
func newMetadataMutation(c config, op Op, opts ...metadataOption) *MetadataMutation {
	m := &MetadataMutation{
		config:        c,
		op:            op,
		typ:           TypeMetadata,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMetadataID sets the ID field of the mutation.
func withMetadataID(id int) metadataOption {
	return func(m *MetadataMutation) {
		var (
			err   error
			once  sync.Once
			value *Metadata
		)
		m.oldValue = func(ctx context.Context) (*Metadata, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Metadata.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMetadata sets the old Metadata of the mutation.
func withMetadata(node *Metadata) metadataOption {
	return func(m *MetadataMutation) {
		m.oldValue = func(context.Context) (*Metadata, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MetadataMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MetadataMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MetadataMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MetadataMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Metadata.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *MetadataMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MetadataMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Metadata entity.
// If the Metadata object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetadataMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MetadataMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MetadataMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MetadataMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Metadata entity.
// If the Metadata object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetadataMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MetadataMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *MetadataMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *MetadataMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Metadata entity.
// If the Metadata object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetadataMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *MetadataMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[metadata.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *MetadataMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[metadata.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *MetadataMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, metadata.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *MetadataMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *MetadataMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Metadata entity.
// If the Metadata object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetadataMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *MetadataMutation) ResetName() {
	m.name = nil
}

// SetValue sets the "value" field.
func (m *MetadataMutation) SetValue(s string) {
	m.value = &s
}

// Value returns the value of the "value" field in the mutation.
func (m *MetadataMutation) Value() (r string, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the Metadata entity.
// If the Metadata object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetadataMutation) OldValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ResetValue resets all changes to the "value" field.
func (m *MetadataMutation) ResetValue() {
	m.value = nil
}

// SetFileID sets the "file_id" field.
func (m *MetadataMutation) SetFileID(i int) {
	m.file = &i
}

// FileID returns the value of the "file_id" field in the mutation.
func (m *MetadataMutation) FileID() (r int, exists bool) {
	v := m.file
	if v == nil {
		return
	}
	return *v, true
}

// OldFileID returns the old "file_id" field's value of the Metadata entity.
// If the Metadata object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetadataMutation) OldFileID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFileID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFileID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFileID: %w", err)
	}
	return oldValue.FileID, nil
}

// ResetFileID resets all changes to the "file_id" field.
func (m *MetadataMutation) ResetFileID() {
	m.file = nil
}

// SetIsPublic sets the "is_public" field.
func (m *MetadataMutation) SetIsPublic(b bool) {
	m.is_public = &b
}

// IsPublic returns the value of the "is_public" field in the mutation.
func (m *MetadataMutation) IsPublic() (r bool, exists bool) {
	v := m.is_public
	if v == nil {
		return
	}
	return *v, true
}

// OldIsPublic returns the old "is_public" field's value of the Metadata entity.
// If the Metadata object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetadataMutation) OldIsPublic(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsPublic is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsPublic requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsPublic: %w", err)
	}
	return oldValue.IsPublic, nil
}

// ResetIsPublic resets all changes to the "is_public" field.
func (m *MetadataMutation) ResetIsPublic() {
	m.is_public = nil
}

// ClearFile clears the "file" edge to the File entity.
func (m *MetadataMutation) ClearFile() {
	m.clearedfile = true
	m.clearedFields[metadata.FieldFileID] = struct{}{}
}

// FileCleared reports if the "file" edge to the File entity was cleared.
func (m *MetadataMutation) FileCleared() bool {
	return m.clearedfile
}

// FileIDs returns the "file" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FileID instead. It exists only for internal usage by the builders.
func (m *MetadataMutation) FileIDs() (ids []int) {
	if id := m.file; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFile resets all changes to the "file" edge.
func (m *MetadataMutation) ResetFile() {
	m.file = nil
	m.clearedfile = false
}

// Where appends a list predicates to the MetadataMutation builder.
func (m *MetadataMutation) Where(ps ...predicate.Metadata) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MetadataMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MetadataMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Metadata, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MetadataMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MetadataMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Metadata).
func (m *MetadataMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MetadataMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, metadata.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, metadata.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, metadata.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, metadata.FieldName)
	}
	if m.value != nil {
		fields = append(fields, metadata.FieldValue)
	}
	if m.file != nil {
		fields = append(fields, metadata.FieldFileID)
	}
	if m.is_public != nil {
		fields = append(fields, metadata.FieldIsPublic)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MetadataMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case metadata.FieldCreatedAt:
		return m.CreatedAt()
	case metadata.FieldUpdatedAt:
		return m.UpdatedAt()
	case metadata.FieldDeletedAt:
		return m.DeletedAt()
	case metadata.FieldName:
		return m.Name()
	case metadata.FieldValue:
		return m.Value()
	case metadata.FieldFileID:
		return m.FileID()
	case metadata.FieldIsPublic:
		return m.IsPublic()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MetadataMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case metadata.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case metadata.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case metadata.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case metadata.FieldName:
		return m.OldName(ctx)
	case metadata.FieldValue:
		return m.OldValue(ctx)
	case metadata.FieldFileID:
		return m.OldFileID(ctx)
	case metadata.FieldIsPublic:
		return m.OldIsPublic(ctx)
	}
	return nil, fmt.Errorf("unknown Metadata field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MetadataMutation) SetField(name string, value ent.Value) error {
	switch name {
	case metadata.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case metadata.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case metadata.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case metadata.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case metadata.FieldValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	case metadata.FieldFileID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFileID(v)
		return nil
	case metadata.FieldIsPublic:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsPublic(v)
		return nil
	}
	return fmt.Errorf("unknown Metadata field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MetadataMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MetadataMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MetadataMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Metadata numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MetadataMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(metadata.FieldDeletedAt) {
		fields = append(fields, metadata.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MetadataMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MetadataMutation) ClearField(name string) error {
	switch name {
	case metadata.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Metadata nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MetadataMutation) ResetField(name string) error {
	switch name {
	case metadata.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case metadata.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case metadata.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case metadata.FieldName:
		m.ResetName()
		return nil
	case metadata.FieldValue:
		m.ResetValue()
		return nil
	case metadata.FieldFileID:
		m.ResetFileID()
		return nil
	case metadata.FieldIsPublic:
		m.ResetIsPublic()
		return nil
	}
	return fmt.Errorf("unknown Metadata field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MetadataMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.file != nil {
		edges = append(edges, metadata.EdgeFile)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MetadataMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case metadata.EdgeFile:
		if id := m.file; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MetadataMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MetadataMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MetadataMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedfile {
		edges = append(edges, metadata.EdgeFile)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MetadataMutation) EdgeCleared(name string) bool {
	switch name {
	case metadata.EdgeFile:
		return m.clearedfile
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MetadataMutation) ClearEdge(name string) error {
	switch name {
	case metadata.EdgeFile:
		m.ClearFile()
		return nil
	}
	return fmt.Errorf("unknown Metadata unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MetadataMutation) ResetEdge(name string) error {
	switch name {
	case metadata.EdgeFile:
		m.ResetFile()
		return nil
	}
	return fmt.Errorf("unknown Metadata edge %s", name)
}

// NodeMutation represents an operation that mutates the Node nodes in the graph.
type NodeMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	created_at            *time.Time
	updated_at            *time.Time
	deleted_at            *time.Time
	status                *node.Status
	name                  *string
	_type                 *node.Type
	server                *string
	slave_key             *string
	capabilities          **boolset.BooleanSet
	settings              **types.NodeSetting
	weight                *int
	addweight             *int
	clearedFields         map[string]struct{}
	storage_policy        map[int]struct{}
	removedstorage_policy map[int]struct{}
	clearedstorage_policy bool
	done                  bool
	oldValue              func(context.Context) (*Node, error)
	predicates            []predicate.Node
}

var _ ent.Mutation = (*NodeMutation)(nil)

// nodeOption allows management of the mutation configuration using functional options.
type nodeOption func(*NodeMutation)

// newNodeMutation creates new mutation for the Node entity.
func newNodeMutation(c config, op Op, opts ...nodeOption) *NodeMutation {
	m := &NodeMutation{
		config:        c,
		op:            op,
		typ:           TypeNode,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNodeID sets the ID field of the mutation.
func withNodeID(id int) nodeOption {
	return func(m *NodeMutation) {
		var (
			err   error
			once  sync.Once
			value *Node
		)
		m.oldValue = func(ctx context.Context) (*Node, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Node.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNode sets the old Node of the mutation.
func withNode(node *Node) nodeOption {
	return func(m *NodeMutation) {
		m.oldValue = func(context.Context) (*Node, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NodeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NodeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NodeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NodeMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Node.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *NodeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *NodeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *NodeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *NodeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *NodeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *NodeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *NodeMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *NodeMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *NodeMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[node.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *NodeMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[node.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *NodeMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, node.FieldDeletedAt)
}

// SetStatus sets the "status" field.
func (m *NodeMutation) SetStatus(n node.Status) {
	m.status = &n
}

// Status returns the value of the "status" field in the mutation.
func (m *NodeMutation) Status() (r node.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldStatus(ctx context.Context) (v node.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *NodeMutation) ResetStatus() {
	m.status = nil
}

// SetName sets the "name" field.
func (m *NodeMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *NodeMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *NodeMutation) ResetName() {
	m.name = nil
}

// SetType sets the "type" field.
func (m *NodeMutation) SetType(n node.Type) {
	m._type = &n
}

// GetType returns the value of the "type" field in the mutation.
func (m *NodeMutation) GetType() (r node.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldType(ctx context.Context) (v node.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *NodeMutation) ResetType() {
	m._type = nil
}

// SetServer sets the "server" field.
func (m *NodeMutation) SetServer(s string) {
	m.server = &s
}

// Server returns the value of the "server" field in the mutation.
func (m *NodeMutation) Server() (r string, exists bool) {
	v := m.server
	if v == nil {
		return
	}
	return *v, true
}

// OldServer returns the old "server" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldServer(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldServer is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldServer requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldServer: %w", err)
	}
	return oldValue.Server, nil
}

// ClearServer clears the value of the "server" field.
func (m *NodeMutation) ClearServer() {
	m.server = nil
	m.clearedFields[node.FieldServer] = struct{}{}
}

// ServerCleared returns if the "server" field was cleared in this mutation.
func (m *NodeMutation) ServerCleared() bool {
	_, ok := m.clearedFields[node.FieldServer]
	return ok
}

// ResetServer resets all changes to the "server" field.
func (m *NodeMutation) ResetServer() {
	m.server = nil
	delete(m.clearedFields, node.FieldServer)
}

// SetSlaveKey sets the "slave_key" field.
func (m *NodeMutation) SetSlaveKey(s string) {
	m.slave_key = &s
}

// SlaveKey returns the value of the "slave_key" field in the mutation.
func (m *NodeMutation) SlaveKey() (r string, exists bool) {
	v := m.slave_key
	if v == nil {
		return
	}
	return *v, true
}

// OldSlaveKey returns the old "slave_key" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldSlaveKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSlaveKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSlaveKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSlaveKey: %w", err)
	}
	return oldValue.SlaveKey, nil
}

// ClearSlaveKey clears the value of the "slave_key" field.
func (m *NodeMutation) ClearSlaveKey() {
	m.slave_key = nil
	m.clearedFields[node.FieldSlaveKey] = struct{}{}
}

// SlaveKeyCleared returns if the "slave_key" field was cleared in this mutation.
func (m *NodeMutation) SlaveKeyCleared() bool {
	_, ok := m.clearedFields[node.FieldSlaveKey]
	return ok
}

// ResetSlaveKey resets all changes to the "slave_key" field.
func (m *NodeMutation) ResetSlaveKey() {
	m.slave_key = nil
	delete(m.clearedFields, node.FieldSlaveKey)
}

// SetCapabilities sets the "capabilities" field.
func (m *NodeMutation) SetCapabilities(bs *boolset.BooleanSet) {
	m.capabilities = &bs
}

// Capabilities returns the value of the "capabilities" field in the mutation.
func (m *NodeMutation) Capabilities() (r *boolset.BooleanSet, exists bool) {
	v := m.capabilities
	if v == nil {
		return
	}
	return *v, true
}

// OldCapabilities returns the old "capabilities" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldCapabilities(ctx context.Context) (v *boolset.BooleanSet, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCapabilities is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCapabilities requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCapabilities: %w", err)
	}
	return oldValue.Capabilities, nil
}

// ResetCapabilities resets all changes to the "capabilities" field.
func (m *NodeMutation) ResetCapabilities() {
	m.capabilities = nil
}

// SetSettings sets the "settings" field.
func (m *NodeMutation) SetSettings(ts *types.NodeSetting) {
	m.settings = &ts
}

// Settings returns the value of the "settings" field in the mutation.
func (m *NodeMutation) Settings() (r *types.NodeSetting, exists bool) {
	v := m.settings
	if v == nil {
		return
	}
	return *v, true
}

// OldSettings returns the old "settings" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldSettings(ctx context.Context) (v *types.NodeSetting, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSettings is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSettings requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSettings: %w", err)
	}
	return oldValue.Settings, nil
}

// ClearSettings clears the value of the "settings" field.
func (m *NodeMutation) ClearSettings() {
	m.settings = nil
	m.clearedFields[node.FieldSettings] = struct{}{}
}

// SettingsCleared returns if the "settings" field was cleared in this mutation.
func (m *NodeMutation) SettingsCleared() bool {
	_, ok := m.clearedFields[node.FieldSettings]
	return ok
}

// ResetSettings resets all changes to the "settings" field.
func (m *NodeMutation) ResetSettings() {
	m.settings = nil
	delete(m.clearedFields, node.FieldSettings)
}

// SetWeight sets the "weight" field.
func (m *NodeMutation) SetWeight(i int) {
	m.weight = &i
	m.addweight = nil
}

// Weight returns the value of the "weight" field in the mutation.
func (m *NodeMutation) Weight() (r int, exists bool) {
	v := m.weight
	if v == nil {
		return
	}
	return *v, true
}

// OldWeight returns the old "weight" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldWeight(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWeight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWeight: %w", err)
	}
	return oldValue.Weight, nil
}

// AddWeight adds i to the "weight" field.
func (m *NodeMutation) AddWeight(i int) {
	if m.addweight != nil {
		*m.addweight += i
	} else {
		m.addweight = &i
	}
}

// AddedWeight returns the value that was added to the "weight" field in this mutation.
func (m *NodeMutation) AddedWeight() (r int, exists bool) {
	v := m.addweight
	if v == nil {
		return
	}
	return *v, true
}

// ResetWeight resets all changes to the "weight" field.
func (m *NodeMutation) ResetWeight() {
	m.weight = nil
	m.addweight = nil
}

// AddStoragePolicyIDs adds the "storage_policy" edge to the StoragePolicy entity by ids.
func (m *NodeMutation) AddStoragePolicyIDs(ids ...int) {
	if m.storage_policy == nil {
		m.storage_policy = make(map[int]struct{})
	}
	for i := range ids {
		m.storage_policy[ids[i]] = struct{}{}
	}
}

// ClearStoragePolicy clears the "storage_policy" edge to the StoragePolicy entity.
func (m *NodeMutation) ClearStoragePolicy() {
	m.clearedstorage_policy = true
}

// StoragePolicyCleared reports if the "storage_policy" edge to the StoragePolicy entity was cleared.
func (m *NodeMutation) StoragePolicyCleared() bool {
	return m.clearedstorage_policy
}

// RemoveStoragePolicyIDs removes the "storage_policy" edge to the StoragePolicy entity by IDs.
func (m *NodeMutation) RemoveStoragePolicyIDs(ids ...int) {
	if m.removedstorage_policy == nil {
		m.removedstorage_policy = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.storage_policy, ids[i])
		m.removedstorage_policy[ids[i]] = struct{}{}
	}
}

// RemovedStoragePolicy returns the removed IDs of the "storage_policy" edge to the StoragePolicy entity.
func (m *NodeMutation) RemovedStoragePolicyIDs() (ids []int) {
	for id := range m.removedstorage_policy {
		ids = append(ids, id)
	}
	return
}

// StoragePolicyIDs returns the "storage_policy" edge IDs in the mutation.
func (m *NodeMutation) StoragePolicyIDs() (ids []int) {
	for id := range m.storage_policy {
		ids = append(ids, id)
	}
	return
}

// ResetStoragePolicy resets all changes to the "storage_policy" edge.
func (m *NodeMutation) ResetStoragePolicy() {
	m.storage_policy = nil
	m.clearedstorage_policy = false
	m.removedstorage_policy = nil
}

// Where appends a list predicates to the NodeMutation builder.
func (m *NodeMutation) Where(ps ...predicate.Node) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the NodeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *NodeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Node, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *NodeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *NodeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Node).
func (m *NodeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NodeMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.created_at != nil {
		fields = append(fields, node.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, node.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, node.FieldDeletedAt)
	}
	if m.status != nil {
		fields = append(fields, node.FieldStatus)
	}
	if m.name != nil {
		fields = append(fields, node.FieldName)
	}
	if m._type != nil {
		fields = append(fields, node.FieldType)
	}
	if m.server != nil {
		fields = append(fields, node.FieldServer)
	}
	if m.slave_key != nil {
		fields = append(fields, node.FieldSlaveKey)
	}
	if m.capabilities != nil {
		fields = append(fields, node.FieldCapabilities)
	}
	if m.settings != nil {
		fields = append(fields, node.FieldSettings)
	}
	if m.weight != nil {
		fields = append(fields, node.FieldWeight)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NodeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case node.FieldCreatedAt:
		return m.CreatedAt()
	case node.FieldUpdatedAt:
		return m.UpdatedAt()
	case node.FieldDeletedAt:
		return m.DeletedAt()
	case node.FieldStatus:
		return m.Status()
	case node.FieldName:
		return m.Name()
	case node.FieldType:
		return m.GetType()
	case node.FieldServer:
		return m.Server()
	case node.FieldSlaveKey:
		return m.SlaveKey()
	case node.FieldCapabilities:
		return m.Capabilities()
	case node.FieldSettings:
		return m.Settings()
	case node.FieldWeight:
		return m.Weight()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NodeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case node.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case node.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case node.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case node.FieldStatus:
		return m.OldStatus(ctx)
	case node.FieldName:
		return m.OldName(ctx)
	case node.FieldType:
		return m.OldType(ctx)
	case node.FieldServer:
		return m.OldServer(ctx)
	case node.FieldSlaveKey:
		return m.OldSlaveKey(ctx)
	case node.FieldCapabilities:
		return m.OldCapabilities(ctx)
	case node.FieldSettings:
		return m.OldSettings(ctx)
	case node.FieldWeight:
		return m.OldWeight(ctx)
	}
	return nil, fmt.Errorf("unknown Node field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NodeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case node.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case node.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case node.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case node.FieldStatus:
		v, ok := value.(node.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case node.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case node.FieldType:
		v, ok := value.(node.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case node.FieldServer:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetServer(v)
		return nil
	case node.FieldSlaveKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSlaveKey(v)
		return nil
	case node.FieldCapabilities:
		v, ok := value.(*boolset.BooleanSet)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCapabilities(v)
		return nil
	case node.FieldSettings:
		v, ok := value.(*types.NodeSetting)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSettings(v)
		return nil
	case node.FieldWeight:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWeight(v)
		return nil
	}
	return fmt.Errorf("unknown Node field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NodeMutation) AddedFields() []string {
	var fields []string
	if m.addweight != nil {
		fields = append(fields, node.FieldWeight)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NodeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case node.FieldWeight:
		return m.AddedWeight()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NodeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case node.FieldWeight:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWeight(v)
		return nil
	}
	return fmt.Errorf("unknown Node numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NodeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(node.FieldDeletedAt) {
		fields = append(fields, node.FieldDeletedAt)
	}
	if m.FieldCleared(node.FieldServer) {
		fields = append(fields, node.FieldServer)
	}
	if m.FieldCleared(node.FieldSlaveKey) {
		fields = append(fields, node.FieldSlaveKey)
	}
	if m.FieldCleared(node.FieldSettings) {
		fields = append(fields, node.FieldSettings)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NodeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NodeMutation) ClearField(name string) error {
	switch name {
	case node.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case node.FieldServer:
		m.ClearServer()
		return nil
	case node.FieldSlaveKey:
		m.ClearSlaveKey()
		return nil
	case node.FieldSettings:
		m.ClearSettings()
		return nil
	}
	return fmt.Errorf("unknown Node nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NodeMutation) ResetField(name string) error {
	switch name {
	case node.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case node.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case node.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case node.FieldStatus:
		m.ResetStatus()
		return nil
	case node.FieldName:
		m.ResetName()
		return nil
	case node.FieldType:
		m.ResetType()
		return nil
	case node.FieldServer:
		m.ResetServer()
		return nil
	case node.FieldSlaveKey:
		m.ResetSlaveKey()
		return nil
	case node.FieldCapabilities:
		m.ResetCapabilities()
		return nil
	case node.FieldSettings:
		m.ResetSettings()
		return nil
	case node.FieldWeight:
		m.ResetWeight()
		return nil
	}
	return fmt.Errorf("unknown Node field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NodeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.storage_policy != nil {
		edges = append(edges, node.EdgeStoragePolicy)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NodeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case node.EdgeStoragePolicy:
		ids := make([]ent.Value, 0, len(m.storage_policy))
		for id := range m.storage_policy {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NodeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedstorage_policy != nil {
		edges = append(edges, node.EdgeStoragePolicy)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NodeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case node.EdgeStoragePolicy:
		ids := make([]ent.Value, 0, len(m.removedstorage_policy))
		for id := range m.removedstorage_policy {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NodeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedstorage_policy {
		edges = append(edges, node.EdgeStoragePolicy)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NodeMutation) EdgeCleared(name string) bool {
	switch name {
	case node.EdgeStoragePolicy:
		return m.clearedstorage_policy
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NodeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Node unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NodeMutation) ResetEdge(name string) error {
	switch name {
	case node.EdgeStoragePolicy:
		m.ResetStoragePolicy()
		return nil
	}
	return fmt.Errorf("unknown Node edge %s", name)
}

// PasskeyMutation represents an operation that mutates the Passkey nodes in the graph.
type PasskeyMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	credential_id *string
	name          *string
	credential    **webauthn.Credential
	used_at       *time.Time
	clearedFields map[string]struct{}
	user          *int
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*Passkey, error)
	predicates    []predicate.Passkey
}

var _ ent.Mutation = (*PasskeyMutation)(nil)

// passkeyOption allows management of the mutation configuration using functional options.
type passkeyOption func(*PasskeyMutation)

// newPasskeyMutation creates new mutation for the Passkey entity.
func newPasskeyMutation(c config, op Op, opts ...passkeyOption) *PasskeyMutation {
	m := &PasskeyMutation{
		config:        c,
		op:            op,
		typ:           TypePasskey,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPasskeyID sets the ID field of the mutation.
func withPasskeyID(id int) passkeyOption {
	return func(m *PasskeyMutation) {
		var (
			err   error
			once  sync.Once
			value *Passkey
		)
		m.oldValue = func(ctx context.Context) (*Passkey, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Passkey.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPasskey sets the old Passkey of the mutation.
func withPasskey(node *Passkey) passkeyOption {
	return func(m *PasskeyMutation) {
		m.oldValue = func(context.Context) (*Passkey, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PasskeyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PasskeyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PasskeyMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PasskeyMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Passkey.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PasskeyMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PasskeyMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Passkey entity.
// If the Passkey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PasskeyMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PasskeyMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PasskeyMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PasskeyMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Passkey entity.
// If the Passkey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PasskeyMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PasskeyMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *PasskeyMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *PasskeyMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Passkey entity.
// If the Passkey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PasskeyMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *PasskeyMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[passkey.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *PasskeyMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[passkey.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *PasskeyMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, passkey.FieldDeletedAt)
}

// SetUserID sets the "user_id" field.
func (m *PasskeyMutation) SetUserID(i int) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *PasskeyMutation) UserID() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Passkey entity.
// If the Passkey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PasskeyMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *PasskeyMutation) ResetUserID() {
	m.user = nil
}

// SetCredentialID sets the "credential_id" field.
func (m *PasskeyMutation) SetCredentialID(s string) {
	m.credential_id = &s
}

// CredentialID returns the value of the "credential_id" field in the mutation.
func (m *PasskeyMutation) CredentialID() (r string, exists bool) {
	v := m.credential_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCredentialID returns the old "credential_id" field's value of the Passkey entity.
// If the Passkey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PasskeyMutation) OldCredentialID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCredentialID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCredentialID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCredentialID: %w", err)
	}
	return oldValue.CredentialID, nil
}

// ResetCredentialID resets all changes to the "credential_id" field.
func (m *PasskeyMutation) ResetCredentialID() {
	m.credential_id = nil
}

// SetName sets the "name" field.
func (m *PasskeyMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PasskeyMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Passkey entity.
// If the Passkey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PasskeyMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *PasskeyMutation) ResetName() {
	m.name = nil
}

// SetCredential sets the "credential" field.
func (m *PasskeyMutation) SetCredential(w *webauthn.Credential) {
	m.credential = &w
}

// Credential returns the value of the "credential" field in the mutation.
func (m *PasskeyMutation) Credential() (r *webauthn.Credential, exists bool) {
	v := m.credential
	if v == nil {
		return
	}
	return *v, true
}

// OldCredential returns the old "credential" field's value of the Passkey entity.
// If the Passkey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PasskeyMutation) OldCredential(ctx context.Context) (v *webauthn.Credential, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCredential is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCredential requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCredential: %w", err)
	}
	return oldValue.Credential, nil
}

// ResetCredential resets all changes to the "credential" field.
func (m *PasskeyMutation) ResetCredential() {
	m.credential = nil
}

// SetUsedAt sets the "used_at" field.
func (m *PasskeyMutation) SetUsedAt(t time.Time) {
	m.used_at = &t
}

// UsedAt returns the value of the "used_at" field in the mutation.
func (m *PasskeyMutation) UsedAt() (r time.Time, exists bool) {
	v := m.used_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUsedAt returns the old "used_at" field's value of the Passkey entity.
// If the Passkey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PasskeyMutation) OldUsedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsedAt: %w", err)
	}
	return oldValue.UsedAt, nil
}

// ClearUsedAt clears the value of the "used_at" field.
func (m *PasskeyMutation) ClearUsedAt() {
	m.used_at = nil
	m.clearedFields[passkey.FieldUsedAt] = struct{}{}
}

// UsedAtCleared returns if the "used_at" field was cleared in this mutation.
func (m *PasskeyMutation) UsedAtCleared() bool {
	_, ok := m.clearedFields[passkey.FieldUsedAt]
	return ok
}

// ResetUsedAt resets all changes to the "used_at" field.
func (m *PasskeyMutation) ResetUsedAt() {
	m.used_at = nil
	delete(m.clearedFields, passkey.FieldUsedAt)
}

// ClearUser clears the "user" edge to the User entity.
func (m *PasskeyMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[passkey.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *PasskeyMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *PasskeyMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *PasskeyMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the PasskeyMutation builder.
func (m *PasskeyMutation) Where(ps ...predicate.Passkey) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PasskeyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PasskeyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Passkey, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PasskeyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PasskeyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Passkey).
func (m *PasskeyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PasskeyMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, passkey.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, passkey.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, passkey.FieldDeletedAt)
	}
	if m.user != nil {
		fields = append(fields, passkey.FieldUserID)
	}
	if m.credential_id != nil {
		fields = append(fields, passkey.FieldCredentialID)
	}
	if m.name != nil {
		fields = append(fields, passkey.FieldName)
	}
	if m.credential != nil {
		fields = append(fields, passkey.FieldCredential)
	}
	if m.used_at != nil {
		fields = append(fields, passkey.FieldUsedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PasskeyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case passkey.FieldCreatedAt:
		return m.CreatedAt()
	case passkey.FieldUpdatedAt:
		return m.UpdatedAt()
	case passkey.FieldDeletedAt:
		return m.DeletedAt()
	case passkey.FieldUserID:
		return m.UserID()
	case passkey.FieldCredentialID:
		return m.CredentialID()
	case passkey.FieldName:
		return m.Name()
	case passkey.FieldCredential:
		return m.Credential()
	case passkey.FieldUsedAt:
		return m.UsedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PasskeyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case passkey.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case passkey.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case passkey.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case passkey.FieldUserID:
		return m.OldUserID(ctx)
	case passkey.FieldCredentialID:
		return m.OldCredentialID(ctx)
	case passkey.FieldName:
		return m.OldName(ctx)
	case passkey.FieldCredential:
		return m.OldCredential(ctx)
	case passkey.FieldUsedAt:
		return m.OldUsedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Passkey field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PasskeyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case passkey.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case passkey.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case passkey.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case passkey.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case passkey.FieldCredentialID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCredentialID(v)
		return nil
	case passkey.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case passkey.FieldCredential:
		v, ok := value.(*webauthn.Credential)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCredential(v)
		return nil
	case passkey.FieldUsedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Passkey field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PasskeyMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PasskeyMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PasskeyMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Passkey numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PasskeyMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(passkey.FieldDeletedAt) {
		fields = append(fields, passkey.FieldDeletedAt)
	}
	if m.FieldCleared(passkey.FieldUsedAt) {
		fields = append(fields, passkey.FieldUsedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PasskeyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PasskeyMutation) ClearField(name string) error {
	switch name {
	case passkey.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case passkey.FieldUsedAt:
		m.ClearUsedAt()
		return nil
	}
	return fmt.Errorf("unknown Passkey nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PasskeyMutation) ResetField(name string) error {
	switch name {
	case passkey.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case passkey.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case passkey.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case passkey.FieldUserID:
		m.ResetUserID()
		return nil
	case passkey.FieldCredentialID:
		m.ResetCredentialID()
		return nil
	case passkey.FieldName:
		m.ResetName()
		return nil
	case passkey.FieldCredential:
		m.ResetCredential()
		return nil
	case passkey.FieldUsedAt:
		m.ResetUsedAt()
		return nil
	}
	return fmt.Errorf("unknown Passkey field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PasskeyMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, passkey.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PasskeyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case passkey.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PasskeyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PasskeyMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PasskeyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, passkey.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PasskeyMutation) EdgeCleared(name string) bool {
	switch name {
	case passkey.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PasskeyMutation) ClearEdge(name string) error {
	switch name {
	case passkey.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Passkey unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PasskeyMutation) ResetEdge(name string) error {
	switch name {
	case passkey.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown Passkey edge %s", name)
}

// SettingMutation represents an operation that mutates the Setting nodes in the graph.
type SettingMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	name          *string
	value         *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Setting, error)
	predicates    []predicate.Setting
}

var _ ent.Mutation = (*SettingMutation)(nil)

// settingOption allows management of the mutation configuration using functional options.
type settingOption func(*SettingMutation)

// newSettingMutation creates new mutation for the Setting entity.
func newSettingMutation(c config, op Op, opts ...settingOption) *SettingMutation {
	m := &SettingMutation{
		config:        c,
		op:            op,
		typ:           TypeSetting,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSettingID sets the ID field of the mutation.
func withSettingID(id int) settingOption {
	return func(m *SettingMutation) {
		var (
			err   error
			once  sync.Once
			value *Setting
		)
		m.oldValue = func(ctx context.Context) (*Setting, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Setting.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSetting sets the old Setting of the mutation.
func withSetting(node *Setting) settingOption {
	return func(m *SettingMutation) {
		m.oldValue = func(context.Context) (*Setting, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SettingMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SettingMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SettingMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SettingMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Setting.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *SettingMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SettingMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SettingMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SettingMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SettingMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SettingMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *SettingMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *SettingMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *SettingMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[setting.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *SettingMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[setting.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *SettingMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, setting.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *SettingMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *SettingMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *SettingMutation) ResetName() {
	m.name = nil
}

// SetValue sets the "value" field.
func (m *SettingMutation) SetValue(s string) {
	m.value = &s
}

// Value returns the value of the "value" field in the mutation.
func (m *SettingMutation) Value() (r string, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ClearValue clears the value of the "value" field.
func (m *SettingMutation) ClearValue() {
	m.value = nil
	m.clearedFields[setting.FieldValue] = struct{}{}
}

// ValueCleared returns if the "value" field was cleared in this mutation.
func (m *SettingMutation) ValueCleared() bool {
	_, ok := m.clearedFields[setting.FieldValue]
	return ok
}

// ResetValue resets all changes to the "value" field.
func (m *SettingMutation) ResetValue() {
	m.value = nil
	delete(m.clearedFields, setting.FieldValue)
}

// Where appends a list predicates to the SettingMutation builder.
func (m *SettingMutation) Where(ps ...predicate.Setting) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SettingMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SettingMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Setting, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SettingMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SettingMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Setting).
func (m *SettingMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SettingMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, setting.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, setting.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, setting.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, setting.FieldName)
	}
	if m.value != nil {
		fields = append(fields, setting.FieldValue)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SettingMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case setting.FieldCreatedAt:
		return m.CreatedAt()
	case setting.FieldUpdatedAt:
		return m.UpdatedAt()
	case setting.FieldDeletedAt:
		return m.DeletedAt()
	case setting.FieldName:
		return m.Name()
	case setting.FieldValue:
		return m.Value()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SettingMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case setting.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case setting.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case setting.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case setting.FieldName:
		return m.OldName(ctx)
	case setting.FieldValue:
		return m.OldValue(ctx)
	}
	return nil, fmt.Errorf("unknown Setting field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SettingMutation) SetField(name string, value ent.Value) error {
	switch name {
	case setting.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case setting.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case setting.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case setting.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case setting.FieldValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	}
	return fmt.Errorf("unknown Setting field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SettingMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SettingMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SettingMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Setting numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SettingMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(setting.FieldDeletedAt) {
		fields = append(fields, setting.FieldDeletedAt)
	}
	if m.FieldCleared(setting.FieldValue) {
		fields = append(fields, setting.FieldValue)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SettingMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SettingMutation) ClearField(name string) error {
	switch name {
	case setting.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case setting.FieldValue:
		m.ClearValue()
		return nil
	}
	return fmt.Errorf("unknown Setting nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SettingMutation) ResetField(name string) error {
	switch name {
	case setting.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case setting.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case setting.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case setting.FieldName:
		m.ResetName()
		return nil
	case setting.FieldValue:
		m.ResetValue()
		return nil
	}
	return fmt.Errorf("unknown Setting field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SettingMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SettingMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SettingMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SettingMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SettingMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SettingMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SettingMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Setting unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SettingMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Setting edge %s", name)
}

// ShareMutation represents an operation that mutates the Share nodes in the graph.
type ShareMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	created_at          *time.Time
	updated_at          *time.Time
	deleted_at          *time.Time
	password            *string
	views               *int
	addviews            *int
	downloads           *int
	adddownloads        *int
	expires             *time.Time
	remain_downloads    *int
	addremain_downloads *int
	props               **types.ShareProps
	clearedFields       map[string]struct{}
	user                *int
	cleareduser         bool
	file                *int
	clearedfile         bool
	done                bool
	oldValue            func(context.Context) (*Share, error)
	predicates          []predicate.Share
}

var _ ent.Mutation = (*ShareMutation)(nil)

// shareOption allows management of the mutation configuration using functional options.
type shareOption func(*ShareMutation)

// newShareMutation creates new mutation for the Share entity.
func newShareMutation(c config, op Op, opts ...shareOption) *ShareMutation {
	m := &ShareMutation{
		config:        c,
		op:            op,
		typ:           TypeShare,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withShareID sets the ID field of the mutation.
func withShareID(id int) shareOption {
	return func(m *ShareMutation) {
		var (
			err   error
			once  sync.Once
			value *Share
		)
		m.oldValue = func(ctx context.Context) (*Share, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Share.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withShare sets the old Share of the mutation.
func withShare(node *Share) shareOption {
	return func(m *ShareMutation) {
		m.oldValue = func(context.Context) (*Share, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ShareMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ShareMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ShareMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ShareMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Share.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ShareMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ShareMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Share entity.
// If the Share object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShareMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ShareMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ShareMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ShareMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Share entity.
// If the Share object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShareMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ShareMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ShareMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ShareMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Share entity.
// If the Share object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShareMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ShareMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[share.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ShareMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[share.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ShareMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, share.FieldDeletedAt)
}

// SetPassword sets the "password" field.
func (m *ShareMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *ShareMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the Share entity.
// If the Share object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShareMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ClearPassword clears the value of the "password" field.
func (m *ShareMutation) ClearPassword() {
	m.password = nil
	m.clearedFields[share.FieldPassword] = struct{}{}
}

// PasswordCleared returns if the "password" field was cleared in this mutation.
func (m *ShareMutation) PasswordCleared() bool {
	_, ok := m.clearedFields[share.FieldPassword]
	return ok
}

// ResetPassword resets all changes to the "password" field.
func (m *ShareMutation) ResetPassword() {
	m.password = nil
	delete(m.clearedFields, share.FieldPassword)
}

// SetViews sets the "views" field.
func (m *ShareMutation) SetViews(i int) {
	m.views = &i
	m.addviews = nil
}

// Views returns the value of the "views" field in the mutation.
func (m *ShareMutation) Views() (r int, exists bool) {
	v := m.views
	if v == nil {
		return
	}
	return *v, true
}

// OldViews returns the old "views" field's value of the Share entity.
// If the Share object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShareMutation) OldViews(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldViews is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldViews requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldViews: %w", err)
	}
	return oldValue.Views, nil
}

// AddViews adds i to the "views" field.
func (m *ShareMutation) AddViews(i int) {
	if m.addviews != nil {
		*m.addviews += i
	} else {
		m.addviews = &i
	}
}

// AddedViews returns the value that was added to the "views" field in this mutation.
func (m *ShareMutation) AddedViews() (r int, exists bool) {
	v := m.addviews
	if v == nil {
		return
	}
	return *v, true
}

// ResetViews resets all changes to the "views" field.
func (m *ShareMutation) ResetViews() {
	m.views = nil
	m.addviews = nil
}

// SetDownloads sets the "downloads" field.
func (m *ShareMutation) SetDownloads(i int) {
	m.downloads = &i
	m.adddownloads = nil
}

// Downloads returns the value of the "downloads" field in the mutation.
func (m *ShareMutation) Downloads() (r int, exists bool) {
	v := m.downloads
	if v == nil {
		return
	}
	return *v, true
}

// OldDownloads returns the old "downloads" field's value of the Share entity.
// If the Share object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShareMutation) OldDownloads(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDownloads is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDownloads requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDownloads: %w", err)
	}
	return oldValue.Downloads, nil
}

// AddDownloads adds i to the "downloads" field.
func (m *ShareMutation) AddDownloads(i int) {
	if m.adddownloads != nil {
		*m.adddownloads += i
	} else {
		m.adddownloads = &i
	}
}

// AddedDownloads returns the value that was added to the "downloads" field in this mutation.
func (m *ShareMutation) AddedDownloads() (r int, exists bool) {
	v := m.adddownloads
	if v == nil {
		return
	}
	return *v, true
}

// ResetDownloads resets all changes to the "downloads" field.
func (m *ShareMutation) ResetDownloads() {
	m.downloads = nil
	m.adddownloads = nil
}

// SetExpires sets the "expires" field.
func (m *ShareMutation) SetExpires(t time.Time) {
	m.expires = &t
}

// Expires returns the value of the "expires" field in the mutation.
func (m *ShareMutation) Expires() (r time.Time, exists bool) {
	v := m.expires
	if v == nil {
		return
	}
	return *v, true
}

// OldExpires returns the old "expires" field's value of the Share entity.
// If the Share object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShareMutation) OldExpires(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpires is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpires requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpires: %w", err)
	}
	return oldValue.Expires, nil
}

// ClearExpires clears the value of the "expires" field.
func (m *ShareMutation) ClearExpires() {
	m.expires = nil
	m.clearedFields[share.FieldExpires] = struct{}{}
}

// ExpiresCleared returns if the "expires" field was cleared in this mutation.
func (m *ShareMutation) ExpiresCleared() bool {
	_, ok := m.clearedFields[share.FieldExpires]
	return ok
}

// ResetExpires resets all changes to the "expires" field.
func (m *ShareMutation) ResetExpires() {
	m.expires = nil
	delete(m.clearedFields, share.FieldExpires)
}

// SetRemainDownloads sets the "remain_downloads" field.
func (m *ShareMutation) SetRemainDownloads(i int) {
	m.remain_downloads = &i
	m.addremain_downloads = nil
}

// RemainDownloads returns the value of the "remain_downloads" field in the mutation.
func (m *ShareMutation) RemainDownloads() (r int, exists bool) {
	v := m.remain_downloads
	if v == nil {
		return
	}
	return *v, true
}

// OldRemainDownloads returns the old "remain_downloads" field's value of the Share entity.
// If the Share object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShareMutation) OldRemainDownloads(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemainDownloads is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemainDownloads requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemainDownloads: %w", err)
	}
	return oldValue.RemainDownloads, nil
}

// AddRemainDownloads adds i to the "remain_downloads" field.
func (m *ShareMutation) AddRemainDownloads(i int) {
	if m.addremain_downloads != nil {
		*m.addremain_downloads += i
	} else {
		m.addremain_downloads = &i
	}
}

// AddedRemainDownloads returns the value that was added to the "remain_downloads" field in this mutation.
func (m *ShareMutation) AddedRemainDownloads() (r int, exists bool) {
	v := m.addremain_downloads
	if v == nil {
		return
	}
	return *v, true
}

// ClearRemainDownloads clears the value of the "remain_downloads" field.
func (m *ShareMutation) ClearRemainDownloads() {
	m.remain_downloads = nil
	m.addremain_downloads = nil
	m.clearedFields[share.FieldRemainDownloads] = struct{}{}
}

// RemainDownloadsCleared returns if the "remain_downloads" field was cleared in this mutation.
func (m *ShareMutation) RemainDownloadsCleared() bool {
	_, ok := m.clearedFields[share.FieldRemainDownloads]
	return ok
}

// ResetRemainDownloads resets all changes to the "remain_downloads" field.
func (m *ShareMutation) ResetRemainDownloads() {
	m.remain_downloads = nil
	m.addremain_downloads = nil
	delete(m.clearedFields, share.FieldRemainDownloads)
}

// SetProps sets the "props" field.
func (m *ShareMutation) SetProps(tp *types.ShareProps) {
	m.props = &tp
}

// Props returns the value of the "props" field in the mutation.
func (m *ShareMutation) Props() (r *types.ShareProps, exists bool) {
	v := m.props
	if v == nil {
		return
	}
	return *v, true
}

// OldProps returns the old "props" field's value of the Share entity.
// If the Share object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShareMutation) OldProps(ctx context.Context) (v *types.ShareProps, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProps is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProps requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProps: %w", err)
	}
	return oldValue.Props, nil
}

// ClearProps clears the value of the "props" field.
func (m *ShareMutation) ClearProps() {
	m.props = nil
	m.clearedFields[share.FieldProps] = struct{}{}
}

// PropsCleared returns if the "props" field was cleared in this mutation.
func (m *ShareMutation) PropsCleared() bool {
	_, ok := m.clearedFields[share.FieldProps]
	return ok
}

// ResetProps resets all changes to the "props" field.
func (m *ShareMutation) ResetProps() {
	m.props = nil
	delete(m.clearedFields, share.FieldProps)
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *ShareMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *ShareMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *ShareMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *ShareMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *ShareMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *ShareMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// SetFileID sets the "file" edge to the File entity by id.
func (m *ShareMutation) SetFileID(id int) {
	m.file = &id
}

// ClearFile clears the "file" edge to the File entity.
func (m *ShareMutation) ClearFile() {
	m.clearedfile = true
}

// FileCleared reports if the "file" edge to the File entity was cleared.
func (m *ShareMutation) FileCleared() bool {
	return m.clearedfile
}

// FileID returns the "file" edge ID in the mutation.
func (m *ShareMutation) FileID() (id int, exists bool) {
	if m.file != nil {
		return *m.file, true
	}
	return
}

// FileIDs returns the "file" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FileID instead. It exists only for internal usage by the builders.
func (m *ShareMutation) FileIDs() (ids []int) {
	if id := m.file; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFile resets all changes to the "file" edge.
func (m *ShareMutation) ResetFile() {
	m.file = nil
	m.clearedfile = false
}

// Where appends a list predicates to the ShareMutation builder.
func (m *ShareMutation) Where(ps ...predicate.Share) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ShareMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ShareMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Share, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ShareMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ShareMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Share).
func (m *ShareMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ShareMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, share.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, share.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, share.FieldDeletedAt)
	}
	if m.password != nil {
		fields = append(fields, share.FieldPassword)
	}
	if m.views != nil {
		fields = append(fields, share.FieldViews)
	}
	if m.downloads != nil {
		fields = append(fields, share.FieldDownloads)
	}
	if m.expires != nil {
		fields = append(fields, share.FieldExpires)
	}
	if m.remain_downloads != nil {
		fields = append(fields, share.FieldRemainDownloads)
	}
	if m.props != nil {
		fields = append(fields, share.FieldProps)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ShareMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case share.FieldCreatedAt:
		return m.CreatedAt()
	case share.FieldUpdatedAt:
		return m.UpdatedAt()
	case share.FieldDeletedAt:
		return m.DeletedAt()
	case share.FieldPassword:
		return m.Password()
	case share.FieldViews:
		return m.Views()
	case share.FieldDownloads:
		return m.Downloads()
	case share.FieldExpires:
		return m.Expires()
	case share.FieldRemainDownloads:
		return m.RemainDownloads()
	case share.FieldProps:
		return m.Props()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ShareMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case share.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case share.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case share.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case share.FieldPassword:
		return m.OldPassword(ctx)
	case share.FieldViews:
		return m.OldViews(ctx)
	case share.FieldDownloads:
		return m.OldDownloads(ctx)
	case share.FieldExpires:
		return m.OldExpires(ctx)
	case share.FieldRemainDownloads:
		return m.OldRemainDownloads(ctx)
	case share.FieldProps:
		return m.OldProps(ctx)
	}
	return nil, fmt.Errorf("unknown Share field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ShareMutation) SetField(name string, value ent.Value) error {
	switch name {
	case share.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case share.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case share.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case share.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case share.FieldViews:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetViews(v)
		return nil
	case share.FieldDownloads:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDownloads(v)
		return nil
	case share.FieldExpires:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpires(v)
		return nil
	case share.FieldRemainDownloads:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemainDownloads(v)
		return nil
	case share.FieldProps:
		v, ok := value.(*types.ShareProps)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProps(v)
		return nil
	}
	return fmt.Errorf("unknown Share field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ShareMutation) AddedFields() []string {
	var fields []string
	if m.addviews != nil {
		fields = append(fields, share.FieldViews)
	}
	if m.adddownloads != nil {
		fields = append(fields, share.FieldDownloads)
	}
	if m.addremain_downloads != nil {
		fields = append(fields, share.FieldRemainDownloads)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ShareMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case share.FieldViews:
		return m.AddedViews()
	case share.FieldDownloads:
		return m.AddedDownloads()
	case share.FieldRemainDownloads:
		return m.AddedRemainDownloads()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ShareMutation) AddField(name string, value ent.Value) error {
	switch name {
	case share.FieldViews:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddViews(v)
		return nil
	case share.FieldDownloads:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDownloads(v)
		return nil
	case share.FieldRemainDownloads:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRemainDownloads(v)
		return nil
	}
	return fmt.Errorf("unknown Share numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ShareMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(share.FieldDeletedAt) {
		fields = append(fields, share.FieldDeletedAt)
	}
	if m.FieldCleared(share.FieldPassword) {
		fields = append(fields, share.FieldPassword)
	}
	if m.FieldCleared(share.FieldExpires) {
		fields = append(fields, share.FieldExpires)
	}
	if m.FieldCleared(share.FieldRemainDownloads) {
		fields = append(fields, share.FieldRemainDownloads)
	}
	if m.FieldCleared(share.FieldProps) {
		fields = append(fields, share.FieldProps)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ShareMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ShareMutation) ClearField(name string) error {
	switch name {
	case share.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case share.FieldPassword:
		m.ClearPassword()
		return nil
	case share.FieldExpires:
		m.ClearExpires()
		return nil
	case share.FieldRemainDownloads:
		m.ClearRemainDownloads()
		return nil
	case share.FieldProps:
		m.ClearProps()
		return nil
	}
	return fmt.Errorf("unknown Share nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ShareMutation) ResetField(name string) error {
	switch name {
	case share.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case share.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case share.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case share.FieldPassword:
		m.ResetPassword()
		return nil
	case share.FieldViews:
		m.ResetViews()
		return nil
	case share.FieldDownloads:
		m.ResetDownloads()
		return nil
	case share.FieldExpires:
		m.ResetExpires()
		return nil
	case share.FieldRemainDownloads:
		m.ResetRemainDownloads()
		return nil
	case share.FieldProps:
		m.ResetProps()
		return nil
	}
	return fmt.Errorf("unknown Share field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ShareMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, share.EdgeUser)
	}
	if m.file != nil {
		edges = append(edges, share.EdgeFile)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ShareMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case share.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case share.EdgeFile:
		if id := m.file; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ShareMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ShareMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ShareMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, share.EdgeUser)
	}
	if m.clearedfile {
		edges = append(edges, share.EdgeFile)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ShareMutation) EdgeCleared(name string) bool {
	switch name {
	case share.EdgeUser:
		return m.cleareduser
	case share.EdgeFile:
		return m.clearedfile
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ShareMutation) ClearEdge(name string) error {
	switch name {
	case share.EdgeUser:
		m.ClearUser()
		return nil
	case share.EdgeFile:
		m.ClearFile()
		return nil
	}
	return fmt.Errorf("unknown Share unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ShareMutation) ResetEdge(name string) error {
	switch name {
	case share.EdgeUser:
		m.ResetUser()
		return nil
	case share.EdgeFile:
		m.ResetFile()
		return nil
	}
	return fmt.Errorf("unknown Share edge %s", name)
}

// StoragePolicyMutation represents an operation that mutates the StoragePolicy nodes in the graph.
type StoragePolicyMutation struct {
	config
	op              Op
	typ             string
	id              *int
	created_at      *time.Time
	updated_at      *time.Time
	deleted_at      *time.Time
	name            *string
	_type           *string
	server          *string
	bucket_name     *string
	is_private      *bool
	access_key      *string
	secret_key      *string
	max_size        *int64
	addmax_size     *int64
	dir_name_rule   *string
	file_name_rule  *string
	settings        **types.PolicySetting
	clearedFields   map[string]struct{}
	groups          map[int]struct{}
	removedgroups   map[int]struct{}
	clearedgroups   bool
	files           map[int]struct{}
	removedfiles    map[int]struct{}
	clearedfiles    bool
	entities        map[int]struct{}
	removedentities map[int]struct{}
	clearedentities bool
	node            *int
	clearednode     bool
	done            bool
	oldValue        func(context.Context) (*StoragePolicy, error)
	predicates      []predicate.StoragePolicy
}

var _ ent.Mutation = (*StoragePolicyMutation)(nil)

// storagepolicyOption allows management of the mutation configuration using functional options.
type storagepolicyOption func(*StoragePolicyMutation)

// newStoragePolicyMutation creates new mutation for the StoragePolicy entity.
func newStoragePolicyMutation(c config, op Op, opts ...storagepolicyOption) *StoragePolicyMutation {
	m := &StoragePolicyMutation{
		config:        c,
		op:            op,
		typ:           TypeStoragePolicy,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStoragePolicyID sets the ID field of the mutation.
func withStoragePolicyID(id int) storagepolicyOption {
	return func(m *StoragePolicyMutation) {
		var (
			err   error
			once  sync.Once
			value *StoragePolicy
		)
		m.oldValue = func(ctx context.Context) (*StoragePolicy, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().StoragePolicy.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStoragePolicy sets the old StoragePolicy of the mutation.
func withStoragePolicy(node *StoragePolicy) storagepolicyOption {
	return func(m *StoragePolicyMutation) {
		m.oldValue = func(context.Context) (*StoragePolicy, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StoragePolicyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StoragePolicyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *StoragePolicyMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *StoragePolicyMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().StoragePolicy.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *StoragePolicyMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *StoragePolicyMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the StoragePolicy entity.
// If the StoragePolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoragePolicyMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *StoragePolicyMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *StoragePolicyMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *StoragePolicyMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the StoragePolicy entity.
// If the StoragePolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoragePolicyMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *StoragePolicyMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *StoragePolicyMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *StoragePolicyMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the StoragePolicy entity.
// If the StoragePolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoragePolicyMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *StoragePolicyMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[storagepolicy.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *StoragePolicyMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[storagepolicy.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *StoragePolicyMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, storagepolicy.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *StoragePolicyMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *StoragePolicyMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the StoragePolicy entity.
// If the StoragePolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoragePolicyMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *StoragePolicyMutation) ResetName() {
	m.name = nil
}

// SetType sets the "type" field.
func (m *StoragePolicyMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *StoragePolicyMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the StoragePolicy entity.
// If the StoragePolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoragePolicyMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *StoragePolicyMutation) ResetType() {
	m._type = nil
}

// SetServer sets the "server" field.
func (m *StoragePolicyMutation) SetServer(s string) {
	m.server = &s
}

// Server returns the value of the "server" field in the mutation.
func (m *StoragePolicyMutation) Server() (r string, exists bool) {
	v := m.server
	if v == nil {
		return
	}
	return *v, true
}

// OldServer returns the old "server" field's value of the StoragePolicy entity.
// If the StoragePolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoragePolicyMutation) OldServer(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldServer is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldServer requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldServer: %w", err)
	}
	return oldValue.Server, nil
}

// ClearServer clears the value of the "server" field.
func (m *StoragePolicyMutation) ClearServer() {
	m.server = nil
	m.clearedFields[storagepolicy.FieldServer] = struct{}{}
}

// ServerCleared returns if the "server" field was cleared in this mutation.
func (m *StoragePolicyMutation) ServerCleared() bool {
	_, ok := m.clearedFields[storagepolicy.FieldServer]
	return ok
}

// ResetServer resets all changes to the "server" field.
func (m *StoragePolicyMutation) ResetServer() {
	m.server = nil
	delete(m.clearedFields, storagepolicy.FieldServer)
}

// SetBucketName sets the "bucket_name" field.
func (m *StoragePolicyMutation) SetBucketName(s string) {
	m.bucket_name = &s
}

// BucketName returns the value of the "bucket_name" field in the mutation.
func (m *StoragePolicyMutation) BucketName() (r string, exists bool) {
	v := m.bucket_name
	if v == nil {
		return
	}
	return *v, true
}

// OldBucketName returns the old "bucket_name" field's value of the StoragePolicy entity.
// If the StoragePolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoragePolicyMutation) OldBucketName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBucketName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBucketName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBucketName: %w", err)
	}
	return oldValue.BucketName, nil
}

// ClearBucketName clears the value of the "bucket_name" field.
func (m *StoragePolicyMutation) ClearBucketName() {
	m.bucket_name = nil
	m.clearedFields[storagepolicy.FieldBucketName] = struct{}{}
}

// BucketNameCleared returns if the "bucket_name" field was cleared in this mutation.
func (m *StoragePolicyMutation) BucketNameCleared() bool {
	_, ok := m.clearedFields[storagepolicy.FieldBucketName]
	return ok
}

// ResetBucketName resets all changes to the "bucket_name" field.
func (m *StoragePolicyMutation) ResetBucketName() {
	m.bucket_name = nil
	delete(m.clearedFields, storagepolicy.FieldBucketName)
}

// SetIsPrivate sets the "is_private" field.
func (m *StoragePolicyMutation) SetIsPrivate(b bool) {
	m.is_private = &b
}

// IsPrivate returns the value of the "is_private" field in the mutation.
func (m *StoragePolicyMutation) IsPrivate() (r bool, exists bool) {
	v := m.is_private
	if v == nil {
		return
	}
	return *v, true
}

// OldIsPrivate returns the old "is_private" field's value of the StoragePolicy entity.
// If the StoragePolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoragePolicyMutation) OldIsPrivate(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsPrivate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsPrivate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsPrivate: %w", err)
	}
	return oldValue.IsPrivate, nil
}

// ClearIsPrivate clears the value of the "is_private" field.
func (m *StoragePolicyMutation) ClearIsPrivate() {
	m.is_private = nil
	m.clearedFields[storagepolicy.FieldIsPrivate] = struct{}{}
}

// IsPrivateCleared returns if the "is_private" field was cleared in this mutation.
func (m *StoragePolicyMutation) IsPrivateCleared() bool {
	_, ok := m.clearedFields[storagepolicy.FieldIsPrivate]
	return ok
}

// ResetIsPrivate resets all changes to the "is_private" field.
func (m *StoragePolicyMutation) ResetIsPrivate() {
	m.is_private = nil
	delete(m.clearedFields, storagepolicy.FieldIsPrivate)
}

// SetAccessKey sets the "access_key" field.
func (m *StoragePolicyMutation) SetAccessKey(s string) {
	m.access_key = &s
}

// AccessKey returns the value of the "access_key" field in the mutation.
func (m *StoragePolicyMutation) AccessKey() (r string, exists bool) {
	v := m.access_key
	if v == nil {
		return
	}
	return *v, true
}

// OldAccessKey returns the old "access_key" field's value of the StoragePolicy entity.
// If the StoragePolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoragePolicyMutation) OldAccessKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccessKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccessKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccessKey: %w", err)
	}
	return oldValue.AccessKey, nil
}

// ClearAccessKey clears the value of the "access_key" field.
func (m *StoragePolicyMutation) ClearAccessKey() {
	m.access_key = nil
	m.clearedFields[storagepolicy.FieldAccessKey] = struct{}{}
}

// AccessKeyCleared returns if the "access_key" field was cleared in this mutation.
func (m *StoragePolicyMutation) AccessKeyCleared() bool {
	_, ok := m.clearedFields[storagepolicy.FieldAccessKey]
	return ok
}

// ResetAccessKey resets all changes to the "access_key" field.
func (m *StoragePolicyMutation) ResetAccessKey() {
	m.access_key = nil
	delete(m.clearedFields, storagepolicy.FieldAccessKey)
}

// SetSecretKey sets the "secret_key" field.
func (m *StoragePolicyMutation) SetSecretKey(s string) {
	m.secret_key = &s
}

// SecretKey returns the value of the "secret_key" field in the mutation.
func (m *StoragePolicyMutation) SecretKey() (r string, exists bool) {
	v := m.secret_key
	if v == nil {
		return
	}
	return *v, true
}

// OldSecretKey returns the old "secret_key" field's value of the StoragePolicy entity.
// If the StoragePolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoragePolicyMutation) OldSecretKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSecretKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSecretKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSecretKey: %w", err)
	}
	return oldValue.SecretKey, nil
}

// ClearSecretKey clears the value of the "secret_key" field.
func (m *StoragePolicyMutation) ClearSecretKey() {
	m.secret_key = nil
	m.clearedFields[storagepolicy.FieldSecretKey] = struct{}{}
}

// SecretKeyCleared returns if the "secret_key" field was cleared in this mutation.
func (m *StoragePolicyMutation) SecretKeyCleared() bool {
	_, ok := m.clearedFields[storagepolicy.FieldSecretKey]
	return ok
}

// ResetSecretKey resets all changes to the "secret_key" field.
func (m *StoragePolicyMutation) ResetSecretKey() {
	m.secret_key = nil
	delete(m.clearedFields, storagepolicy.FieldSecretKey)
}

// SetMaxSize sets the "max_size" field.
func (m *StoragePolicyMutation) SetMaxSize(i int64) {
	m.max_size = &i
	m.addmax_size = nil
}

// MaxSize returns the value of the "max_size" field in the mutation.
func (m *StoragePolicyMutation) MaxSize() (r int64, exists bool) {
	v := m.max_size
	if v == nil {
		return
	}
	return *v, true
}

// OldMaxSize returns the old "max_size" field's value of the StoragePolicy entity.
// If the StoragePolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoragePolicyMutation) OldMaxSize(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaxSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaxSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaxSize: %w", err)
	}
	return oldValue.MaxSize, nil
}

// AddMaxSize adds i to the "max_size" field.
func (m *StoragePolicyMutation) AddMaxSize(i int64) {
	if m.addmax_size != nil {
		*m.addmax_size += i
	} else {
		m.addmax_size = &i
	}
}

// AddedMaxSize returns the value that was added to the "max_size" field in this mutation.
func (m *StoragePolicyMutation) AddedMaxSize() (r int64, exists bool) {
	v := m.addmax_size
	if v == nil {
		return
	}
	return *v, true
}

// ClearMaxSize clears the value of the "max_size" field.
func (m *StoragePolicyMutation) ClearMaxSize() {
	m.max_size = nil
	m.addmax_size = nil
	m.clearedFields[storagepolicy.FieldMaxSize] = struct{}{}
}

// MaxSizeCleared returns if the "max_size" field was cleared in this mutation.
func (m *StoragePolicyMutation) MaxSizeCleared() bool {
	_, ok := m.clearedFields[storagepolicy.FieldMaxSize]
	return ok
}

// ResetMaxSize resets all changes to the "max_size" field.
func (m *StoragePolicyMutation) ResetMaxSize() {
	m.max_size = nil
	m.addmax_size = nil
	delete(m.clearedFields, storagepolicy.FieldMaxSize)
}

// SetDirNameRule sets the "dir_name_rule" field.
func (m *StoragePolicyMutation) SetDirNameRule(s string) {
	m.dir_name_rule = &s
}

// DirNameRule returns the value of the "dir_name_rule" field in the mutation.
func (m *StoragePolicyMutation) DirNameRule() (r string, exists bool) {
	v := m.dir_name_rule
	if v == nil {
		return
	}
	return *v, true
}

// OldDirNameRule returns the old "dir_name_rule" field's value of the StoragePolicy entity.
// If the StoragePolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoragePolicyMutation) OldDirNameRule(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDirNameRule is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDirNameRule requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDirNameRule: %w", err)
	}
	return oldValue.DirNameRule, nil
}

// ClearDirNameRule clears the value of the "dir_name_rule" field.
func (m *StoragePolicyMutation) ClearDirNameRule() {
	m.dir_name_rule = nil
	m.clearedFields[storagepolicy.FieldDirNameRule] = struct{}{}
}

// DirNameRuleCleared returns if the "dir_name_rule" field was cleared in this mutation.
func (m *StoragePolicyMutation) DirNameRuleCleared() bool {
	_, ok := m.clearedFields[storagepolicy.FieldDirNameRule]
	return ok
}

// ResetDirNameRule resets all changes to the "dir_name_rule" field.
func (m *StoragePolicyMutation) ResetDirNameRule() {
	m.dir_name_rule = nil
	delete(m.clearedFields, storagepolicy.FieldDirNameRule)
}

// SetFileNameRule sets the "file_name_rule" field.
func (m *StoragePolicyMutation) SetFileNameRule(s string) {
	m.file_name_rule = &s
}

// FileNameRule returns the value of the "file_name_rule" field in the mutation.
func (m *StoragePolicyMutation) FileNameRule() (r string, exists bool) {
	v := m.file_name_rule
	if v == nil {
		return
	}
	return *v, true
}

// OldFileNameRule returns the old "file_name_rule" field's value of the StoragePolicy entity.
// If the StoragePolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoragePolicyMutation) OldFileNameRule(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFileNameRule is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFileNameRule requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFileNameRule: %w", err)
	}
	return oldValue.FileNameRule, nil
}

// ClearFileNameRule clears the value of the "file_name_rule" field.
func (m *StoragePolicyMutation) ClearFileNameRule() {
	m.file_name_rule = nil
	m.clearedFields[storagepolicy.FieldFileNameRule] = struct{}{}
}

// FileNameRuleCleared returns if the "file_name_rule" field was cleared in this mutation.
func (m *StoragePolicyMutation) FileNameRuleCleared() bool {
	_, ok := m.clearedFields[storagepolicy.FieldFileNameRule]
	return ok
}

// ResetFileNameRule resets all changes to the "file_name_rule" field.
func (m *StoragePolicyMutation) ResetFileNameRule() {
	m.file_name_rule = nil
	delete(m.clearedFields, storagepolicy.FieldFileNameRule)
}

// SetSettings sets the "settings" field.
func (m *StoragePolicyMutation) SetSettings(ts *types.PolicySetting) {
	m.settings = &ts
}

// Settings returns the value of the "settings" field in the mutation.
func (m *StoragePolicyMutation) Settings() (r *types.PolicySetting, exists bool) {
	v := m.settings
	if v == nil {
		return
	}
	return *v, true
}

// OldSettings returns the old "settings" field's value of the StoragePolicy entity.
// If the StoragePolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoragePolicyMutation) OldSettings(ctx context.Context) (v *types.PolicySetting, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSettings is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSettings requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSettings: %w", err)
	}
	return oldValue.Settings, nil
}

// ClearSettings clears the value of the "settings" field.
func (m *StoragePolicyMutation) ClearSettings() {
	m.settings = nil
	m.clearedFields[storagepolicy.FieldSettings] = struct{}{}
}

// SettingsCleared returns if the "settings" field was cleared in this mutation.
func (m *StoragePolicyMutation) SettingsCleared() bool {
	_, ok := m.clearedFields[storagepolicy.FieldSettings]
	return ok
}

// ResetSettings resets all changes to the "settings" field.
func (m *StoragePolicyMutation) ResetSettings() {
	m.settings = nil
	delete(m.clearedFields, storagepolicy.FieldSettings)
}

// SetNodeID sets the "node_id" field.
func (m *StoragePolicyMutation) SetNodeID(i int) {
	m.node = &i
}

// NodeID returns the value of the "node_id" field in the mutation.
func (m *StoragePolicyMutation) NodeID() (r int, exists bool) {
	v := m.node
	if v == nil {
		return
	}
	return *v, true
}

// OldNodeID returns the old "node_id" field's value of the StoragePolicy entity.
// If the StoragePolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoragePolicyMutation) OldNodeID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNodeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNodeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNodeID: %w", err)
	}
	return oldValue.NodeID, nil
}

// ClearNodeID clears the value of the "node_id" field.
func (m *StoragePolicyMutation) ClearNodeID() {
	m.node = nil
	m.clearedFields[storagepolicy.FieldNodeID] = struct{}{}
}

// NodeIDCleared returns if the "node_id" field was cleared in this mutation.
func (m *StoragePolicyMutation) NodeIDCleared() bool {
	_, ok := m.clearedFields[storagepolicy.FieldNodeID]
	return ok
}

// ResetNodeID resets all changes to the "node_id" field.
func (m *StoragePolicyMutation) ResetNodeID() {
	m.node = nil
	delete(m.clearedFields, storagepolicy.FieldNodeID)
}

// AddGroupIDs adds the "groups" edge to the Group entity by ids.
func (m *StoragePolicyMutation) AddGroupIDs(ids ...int) {
	if m.groups == nil {
		m.groups = make(map[int]struct{})
	}
	for i := range ids {
		m.groups[ids[i]] = struct{}{}
	}
}

// ClearGroups clears the "groups" edge to the Group entity.
func (m *StoragePolicyMutation) ClearGroups() {
	m.clearedgroups = true
}

// GroupsCleared reports if the "groups" edge to the Group entity was cleared.
func (m *StoragePolicyMutation) GroupsCleared() bool {
	return m.clearedgroups
}

// RemoveGroupIDs removes the "groups" edge to the Group entity by IDs.
func (m *StoragePolicyMutation) RemoveGroupIDs(ids ...int) {
	if m.removedgroups == nil {
		m.removedgroups = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.groups, ids[i])
		m.removedgroups[ids[i]] = struct{}{}
	}
}

// RemovedGroups returns the removed IDs of the "groups" edge to the Group entity.
func (m *StoragePolicyMutation) RemovedGroupsIDs() (ids []int) {
	for id := range m.removedgroups {
		ids = append(ids, id)
	}
	return
}

// GroupsIDs returns the "groups" edge IDs in the mutation.
func (m *StoragePolicyMutation) GroupsIDs() (ids []int) {
	for id := range m.groups {
		ids = append(ids, id)
	}
	return
}

// ResetGroups resets all changes to the "groups" edge.
func (m *StoragePolicyMutation) ResetGroups() {
	m.groups = nil
	m.clearedgroups = false
	m.removedgroups = nil
}

// AddFileIDs adds the "files" edge to the File entity by ids.
func (m *StoragePolicyMutation) AddFileIDs(ids ...int) {
	if m.files == nil {
		m.files = make(map[int]struct{})
	}
	for i := range ids {
		m.files[ids[i]] = struct{}{}
	}
}

// ClearFiles clears the "files" edge to the File entity.
func (m *StoragePolicyMutation) ClearFiles() {
	m.clearedfiles = true
}

// FilesCleared reports if the "files" edge to the File entity was cleared.
func (m *StoragePolicyMutation) FilesCleared() bool {
	return m.clearedfiles
}

// RemoveFileIDs removes the "files" edge to the File entity by IDs.
func (m *StoragePolicyMutation) RemoveFileIDs(ids ...int) {
	if m.removedfiles == nil {
		m.removedfiles = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.files, ids[i])
		m.removedfiles[ids[i]] = struct{}{}
	}
}

// RemovedFiles returns the removed IDs of the "files" edge to the File entity.
func (m *StoragePolicyMutation) RemovedFilesIDs() (ids []int) {
	for id := range m.removedfiles {
		ids = append(ids, id)
	}
	return
}

// FilesIDs returns the "files" edge IDs in the mutation.
func (m *StoragePolicyMutation) FilesIDs() (ids []int) {
	for id := range m.files {
		ids = append(ids, id)
	}
	return
}

// ResetFiles resets all changes to the "files" edge.
func (m *StoragePolicyMutation) ResetFiles() {
	m.files = nil
	m.clearedfiles = false
	m.removedfiles = nil
}

// AddEntityIDs adds the "entities" edge to the Entity entity by ids.
func (m *StoragePolicyMutation) AddEntityIDs(ids ...int) {
	if m.entities == nil {
		m.entities = make(map[int]struct{})
	}
	for i := range ids {
		m.entities[ids[i]] = struct{}{}
	}
}

// ClearEntities clears the "entities" edge to the Entity entity.
func (m *StoragePolicyMutation) ClearEntities() {
	m.clearedentities = true
}

// EntitiesCleared reports if the "entities" edge to the Entity entity was cleared.
func (m *StoragePolicyMutation) EntitiesCleared() bool {
	return m.clearedentities
}

// RemoveEntityIDs removes the "entities" edge to the Entity entity by IDs.
func (m *StoragePolicyMutation) RemoveEntityIDs(ids ...int) {
	if m.removedentities == nil {
		m.removedentities = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.entities, ids[i])
		m.removedentities[ids[i]] = struct{}{}
	}
}

// RemovedEntities returns the removed IDs of the "entities" edge to the Entity entity.
func (m *StoragePolicyMutation) RemovedEntitiesIDs() (ids []int) {
	for id := range m.removedentities {
		ids = append(ids, id)
	}
	return
}

// EntitiesIDs returns the "entities" edge IDs in the mutation.
func (m *StoragePolicyMutation) EntitiesIDs() (ids []int) {
	for id := range m.entities {
		ids = append(ids, id)
	}
	return
}

// ResetEntities resets all changes to the "entities" edge.
func (m *StoragePolicyMutation) ResetEntities() {
	m.entities = nil
	m.clearedentities = false
	m.removedentities = nil
}

// ClearNode clears the "node" edge to the Node entity.
func (m *StoragePolicyMutation) ClearNode() {
	m.clearednode = true
	m.clearedFields[storagepolicy.FieldNodeID] = struct{}{}
}

// NodeCleared reports if the "node" edge to the Node entity was cleared.
func (m *StoragePolicyMutation) NodeCleared() bool {
	return m.NodeIDCleared() || m.clearednode
}

// NodeIDs returns the "node" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// NodeID instead. It exists only for internal usage by the builders.
func (m *StoragePolicyMutation) NodeIDs() (ids []int) {
	if id := m.node; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetNode resets all changes to the "node" edge.
func (m *StoragePolicyMutation) ResetNode() {
	m.node = nil
	m.clearednode = false
}

// Where appends a list predicates to the StoragePolicyMutation builder.
func (m *StoragePolicyMutation) Where(ps ...predicate.StoragePolicy) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the StoragePolicyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *StoragePolicyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.StoragePolicy, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *StoragePolicyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *StoragePolicyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (StoragePolicy).
func (m *StoragePolicyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *StoragePolicyMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.created_at != nil {
		fields = append(fields, storagepolicy.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, storagepolicy.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, storagepolicy.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, storagepolicy.FieldName)
	}
	if m._type != nil {
		fields = append(fields, storagepolicy.FieldType)
	}
	if m.server != nil {
		fields = append(fields, storagepolicy.FieldServer)
	}
	if m.bucket_name != nil {
		fields = append(fields, storagepolicy.FieldBucketName)
	}
	if m.is_private != nil {
		fields = append(fields, storagepolicy.FieldIsPrivate)
	}
	if m.access_key != nil {
		fields = append(fields, storagepolicy.FieldAccessKey)
	}
	if m.secret_key != nil {
		fields = append(fields, storagepolicy.FieldSecretKey)
	}
	if m.max_size != nil {
		fields = append(fields, storagepolicy.FieldMaxSize)
	}
	if m.dir_name_rule != nil {
		fields = append(fields, storagepolicy.FieldDirNameRule)
	}
	if m.file_name_rule != nil {
		fields = append(fields, storagepolicy.FieldFileNameRule)
	}
	if m.settings != nil {
		fields = append(fields, storagepolicy.FieldSettings)
	}
	if m.node != nil {
		fields = append(fields, storagepolicy.FieldNodeID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *StoragePolicyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case storagepolicy.FieldCreatedAt:
		return m.CreatedAt()
	case storagepolicy.FieldUpdatedAt:
		return m.UpdatedAt()
	case storagepolicy.FieldDeletedAt:
		return m.DeletedAt()
	case storagepolicy.FieldName:
		return m.Name()
	case storagepolicy.FieldType:
		return m.GetType()
	case storagepolicy.FieldServer:
		return m.Server()
	case storagepolicy.FieldBucketName:
		return m.BucketName()
	case storagepolicy.FieldIsPrivate:
		return m.IsPrivate()
	case storagepolicy.FieldAccessKey:
		return m.AccessKey()
	case storagepolicy.FieldSecretKey:
		return m.SecretKey()
	case storagepolicy.FieldMaxSize:
		return m.MaxSize()
	case storagepolicy.FieldDirNameRule:
		return m.DirNameRule()
	case storagepolicy.FieldFileNameRule:
		return m.FileNameRule()
	case storagepolicy.FieldSettings:
		return m.Settings()
	case storagepolicy.FieldNodeID:
		return m.NodeID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *StoragePolicyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case storagepolicy.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case storagepolicy.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case storagepolicy.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case storagepolicy.FieldName:
		return m.OldName(ctx)
	case storagepolicy.FieldType:
		return m.OldType(ctx)
	case storagepolicy.FieldServer:
		return m.OldServer(ctx)
	case storagepolicy.FieldBucketName:
		return m.OldBucketName(ctx)
	case storagepolicy.FieldIsPrivate:
		return m.OldIsPrivate(ctx)
	case storagepolicy.FieldAccessKey:
		return m.OldAccessKey(ctx)
	case storagepolicy.FieldSecretKey:
		return m.OldSecretKey(ctx)
	case storagepolicy.FieldMaxSize:
		return m.OldMaxSize(ctx)
	case storagepolicy.FieldDirNameRule:
		return m.OldDirNameRule(ctx)
	case storagepolicy.FieldFileNameRule:
		return m.OldFileNameRule(ctx)
	case storagepolicy.FieldSettings:
		return m.OldSettings(ctx)
	case storagepolicy.FieldNodeID:
		return m.OldNodeID(ctx)
	}
	return nil, fmt.Errorf("unknown StoragePolicy field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StoragePolicyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case storagepolicy.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case storagepolicy.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case storagepolicy.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case storagepolicy.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case storagepolicy.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case storagepolicy.FieldServer:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetServer(v)
		return nil
	case storagepolicy.FieldBucketName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBucketName(v)
		return nil
	case storagepolicy.FieldIsPrivate:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsPrivate(v)
		return nil
	case storagepolicy.FieldAccessKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccessKey(v)
		return nil
	case storagepolicy.FieldSecretKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSecretKey(v)
		return nil
	case storagepolicy.FieldMaxSize:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaxSize(v)
		return nil
	case storagepolicy.FieldDirNameRule:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDirNameRule(v)
		return nil
	case storagepolicy.FieldFileNameRule:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFileNameRule(v)
		return nil
	case storagepolicy.FieldSettings:
		v, ok := value.(*types.PolicySetting)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSettings(v)
		return nil
	case storagepolicy.FieldNodeID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNodeID(v)
		return nil
	}
	return fmt.Errorf("unknown StoragePolicy field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *StoragePolicyMutation) AddedFields() []string {
	var fields []string
	if m.addmax_size != nil {
		fields = append(fields, storagepolicy.FieldMaxSize)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *StoragePolicyMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case storagepolicy.FieldMaxSize:
		return m.AddedMaxSize()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StoragePolicyMutation) AddField(name string, value ent.Value) error {
	switch name {
	case storagepolicy.FieldMaxSize:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaxSize(v)
		return nil
	}
	return fmt.Errorf("unknown StoragePolicy numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *StoragePolicyMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(storagepolicy.FieldDeletedAt) {
		fields = append(fields, storagepolicy.FieldDeletedAt)
	}
	if m.FieldCleared(storagepolicy.FieldServer) {
		fields = append(fields, storagepolicy.FieldServer)
	}
	if m.FieldCleared(storagepolicy.FieldBucketName) {
		fields = append(fields, storagepolicy.FieldBucketName)
	}
	if m.FieldCleared(storagepolicy.FieldIsPrivate) {
		fields = append(fields, storagepolicy.FieldIsPrivate)
	}
	if m.FieldCleared(storagepolicy.FieldAccessKey) {
		fields = append(fields, storagepolicy.FieldAccessKey)
	}
	if m.FieldCleared(storagepolicy.FieldSecretKey) {
		fields = append(fields, storagepolicy.FieldSecretKey)
	}
	if m.FieldCleared(storagepolicy.FieldMaxSize) {
		fields = append(fields, storagepolicy.FieldMaxSize)
	}
	if m.FieldCleared(storagepolicy.FieldDirNameRule) {
		fields = append(fields, storagepolicy.FieldDirNameRule)
	}
	if m.FieldCleared(storagepolicy.FieldFileNameRule) {
		fields = append(fields, storagepolicy.FieldFileNameRule)
	}
	if m.FieldCleared(storagepolicy.FieldSettings) {
		fields = append(fields, storagepolicy.FieldSettings)
	}
	if m.FieldCleared(storagepolicy.FieldNodeID) {
		fields = append(fields, storagepolicy.FieldNodeID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *StoragePolicyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *StoragePolicyMutation) ClearField(name string) error {
	switch name {
	case storagepolicy.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case storagepolicy.FieldServer:
		m.ClearServer()
		return nil
	case storagepolicy.FieldBucketName:
		m.ClearBucketName()
		return nil
	case storagepolicy.FieldIsPrivate:
		m.ClearIsPrivate()
		return nil
	case storagepolicy.FieldAccessKey:
		m.ClearAccessKey()
		return nil
	case storagepolicy.FieldSecretKey:
		m.ClearSecretKey()
		return nil
	case storagepolicy.FieldMaxSize:
		m.ClearMaxSize()
		return nil
	case storagepolicy.FieldDirNameRule:
		m.ClearDirNameRule()
		return nil
	case storagepolicy.FieldFileNameRule:
		m.ClearFileNameRule()
		return nil
	case storagepolicy.FieldSettings:
		m.ClearSettings()
		return nil
	case storagepolicy.FieldNodeID:
		m.ClearNodeID()
		return nil
	}
	return fmt.Errorf("unknown StoragePolicy nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *StoragePolicyMutation) ResetField(name string) error {
	switch name {
	case storagepolicy.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case storagepolicy.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case storagepolicy.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case storagepolicy.FieldName:
		m.ResetName()
		return nil
	case storagepolicy.FieldType:
		m.ResetType()
		return nil
	case storagepolicy.FieldServer:
		m.ResetServer()
		return nil
	case storagepolicy.FieldBucketName:
		m.ResetBucketName()
		return nil
	case storagepolicy.FieldIsPrivate:
		m.ResetIsPrivate()
		return nil
	case storagepolicy.FieldAccessKey:
		m.ResetAccessKey()
		return nil
	case storagepolicy.FieldSecretKey:
		m.ResetSecretKey()
		return nil
	case storagepolicy.FieldMaxSize:
		m.ResetMaxSize()
		return nil
	case storagepolicy.FieldDirNameRule:
		m.ResetDirNameRule()
		return nil
	case storagepolicy.FieldFileNameRule:
		m.ResetFileNameRule()
		return nil
	case storagepolicy.FieldSettings:
		m.ResetSettings()
		return nil
	case storagepolicy.FieldNodeID:
		m.ResetNodeID()
		return nil
	}
	return fmt.Errorf("unknown StoragePolicy field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *StoragePolicyMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.groups != nil {
		edges = append(edges, storagepolicy.EdgeGroups)
	}
	if m.files != nil {
		edges = append(edges, storagepolicy.EdgeFiles)
	}
	if m.entities != nil {
		edges = append(edges, storagepolicy.EdgeEntities)
	}
	if m.node != nil {
		edges = append(edges, storagepolicy.EdgeNode)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *StoragePolicyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case storagepolicy.EdgeGroups:
		ids := make([]ent.Value, 0, len(m.groups))
		for id := range m.groups {
			ids = append(ids, id)
		}
		return ids
	case storagepolicy.EdgeFiles:
		ids := make([]ent.Value, 0, len(m.files))
		for id := range m.files {
			ids = append(ids, id)
		}
		return ids
	case storagepolicy.EdgeEntities:
		ids := make([]ent.Value, 0, len(m.entities))
		for id := range m.entities {
			ids = append(ids, id)
		}
		return ids
	case storagepolicy.EdgeNode:
		if id := m.node; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *StoragePolicyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedgroups != nil {
		edges = append(edges, storagepolicy.EdgeGroups)
	}
	if m.removedfiles != nil {
		edges = append(edges, storagepolicy.EdgeFiles)
	}
	if m.removedentities != nil {
		edges = append(edges, storagepolicy.EdgeEntities)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *StoragePolicyMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case storagepolicy.EdgeGroups:
		ids := make([]ent.Value, 0, len(m.removedgroups))
		for id := range m.removedgroups {
			ids = append(ids, id)
		}
		return ids
	case storagepolicy.EdgeFiles:
		ids := make([]ent.Value, 0, len(m.removedfiles))
		for id := range m.removedfiles {
			ids = append(ids, id)
		}
		return ids
	case storagepolicy.EdgeEntities:
		ids := make([]ent.Value, 0, len(m.removedentities))
		for id := range m.removedentities {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *StoragePolicyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedgroups {
		edges = append(edges, storagepolicy.EdgeGroups)
	}
	if m.clearedfiles {
		edges = append(edges, storagepolicy.EdgeFiles)
	}
	if m.clearedentities {
		edges = append(edges, storagepolicy.EdgeEntities)
	}
	if m.clearednode {
		edges = append(edges, storagepolicy.EdgeNode)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *StoragePolicyMutation) EdgeCleared(name string) bool {
	switch name {
	case storagepolicy.EdgeGroups:
		return m.clearedgroups
	case storagepolicy.EdgeFiles:
		return m.clearedfiles
	case storagepolicy.EdgeEntities:
		return m.clearedentities
	case storagepolicy.EdgeNode:
		return m.clearednode
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *StoragePolicyMutation) ClearEdge(name string) error {
	switch name {
	case storagepolicy.EdgeNode:
		m.ClearNode()
		return nil
	}
	return fmt.Errorf("unknown StoragePolicy unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *StoragePolicyMutation) ResetEdge(name string) error {
	switch name {
	case storagepolicy.EdgeGroups:
		m.ResetGroups()
		return nil
	case storagepolicy.EdgeFiles:
		m.ResetFiles()
		return nil
	case storagepolicy.EdgeEntities:
		m.ResetEntities()
		return nil
	case storagepolicy.EdgeNode:
		m.ResetNode()
		return nil
	}
	return fmt.Errorf("unknown StoragePolicy edge %s", name)
}

// TaskMutation represents an operation that mutates the Task nodes in the graph.
type TaskMutation struct {
	config
	op             Op
	typ            string
	id             *int
	created_at     *time.Time
	updated_at     *time.Time
	deleted_at     *time.Time
	_type          *string
	status         *task.Status
	public_state   **types.TaskPublicState
	private_state  *string
	correlation_id *uuid.UUID
	clearedFields  map[string]struct{}
	user           *int
	cleareduser    bool
	done           bool
	oldValue       func(context.Context) (*Task, error)
	predicates     []predicate.Task
}

var _ ent.Mutation = (*TaskMutation)(nil)

// taskOption allows management of the mutation configuration using functional options.
type taskOption func(*TaskMutation)

// newTaskMutation creates new mutation for the Task entity.
func newTaskMutation(c config, op Op, opts ...taskOption) *TaskMutation {
	m := &TaskMutation{
		config:        c,
		op:            op,
		typ:           TypeTask,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTaskID sets the ID field of the mutation.
func withTaskID(id int) taskOption {
	return func(m *TaskMutation) {
		var (
			err   error
			once  sync.Once
			value *Task
		)
		m.oldValue = func(ctx context.Context) (*Task, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Task.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTask sets the old Task of the mutation.
func withTask(node *Task) taskOption {
	return func(m *TaskMutation) {
		m.oldValue = func(context.Context) (*Task, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TaskMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TaskMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TaskMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TaskMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Task.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *TaskMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TaskMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TaskMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TaskMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TaskMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TaskMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *TaskMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *TaskMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *TaskMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[task.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *TaskMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[task.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *TaskMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, task.FieldDeletedAt)
}

// SetType sets the "type" field.
func (m *TaskMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *TaskMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *TaskMutation) ResetType() {
	m._type = nil
}

// SetStatus sets the "status" field.
func (m *TaskMutation) SetStatus(t task.Status) {
	m.status = &t
}

// Status returns the value of the "status" field in the mutation.
func (m *TaskMutation) Status() (r task.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldStatus(ctx context.Context) (v task.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *TaskMutation) ResetStatus() {
	m.status = nil
}

// SetPublicState sets the "public_state" field.
func (m *TaskMutation) SetPublicState(tps *types.TaskPublicState) {
	m.public_state = &tps
}

// PublicState returns the value of the "public_state" field in the mutation.
func (m *TaskMutation) PublicState() (r *types.TaskPublicState, exists bool) {
	v := m.public_state
	if v == nil {
		return
	}
	return *v, true
}

// OldPublicState returns the old "public_state" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldPublicState(ctx context.Context) (v *types.TaskPublicState, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublicState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublicState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublicState: %w", err)
	}
	return oldValue.PublicState, nil
}

// ResetPublicState resets all changes to the "public_state" field.
func (m *TaskMutation) ResetPublicState() {
	m.public_state = nil
}

// SetPrivateState sets the "private_state" field.
func (m *TaskMutation) SetPrivateState(s string) {
	m.private_state = &s
}

// PrivateState returns the value of the "private_state" field in the mutation.
func (m *TaskMutation) PrivateState() (r string, exists bool) {
	v := m.private_state
	if v == nil {
		return
	}
	return *v, true
}

// OldPrivateState returns the old "private_state" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldPrivateState(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrivateState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrivateState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrivateState: %w", err)
	}
	return oldValue.PrivateState, nil
}

// ClearPrivateState clears the value of the "private_state" field.
func (m *TaskMutation) ClearPrivateState() {
	m.private_state = nil
	m.clearedFields[task.FieldPrivateState] = struct{}{}
}

// PrivateStateCleared returns if the "private_state" field was cleared in this mutation.
func (m *TaskMutation) PrivateStateCleared() bool {
	_, ok := m.clearedFields[task.FieldPrivateState]
	return ok
}

// ResetPrivateState resets all changes to the "private_state" field.
func (m *TaskMutation) ResetPrivateState() {
	m.private_state = nil
	delete(m.clearedFields, task.FieldPrivateState)
}

// SetCorrelationID sets the "correlation_id" field.
func (m *TaskMutation) SetCorrelationID(u uuid.UUID) {
	m.correlation_id = &u
}

// CorrelationID returns the value of the "correlation_id" field in the mutation.
func (m *TaskMutation) CorrelationID() (r uuid.UUID, exists bool) {
	v := m.correlation_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCorrelationID returns the old "correlation_id" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldCorrelationID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCorrelationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCorrelationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCorrelationID: %w", err)
	}
	return oldValue.CorrelationID, nil
}

// ClearCorrelationID clears the value of the "correlation_id" field.
func (m *TaskMutation) ClearCorrelationID() {
	m.correlation_id = nil
	m.clearedFields[task.FieldCorrelationID] = struct{}{}
}

// CorrelationIDCleared returns if the "correlation_id" field was cleared in this mutation.
func (m *TaskMutation) CorrelationIDCleared() bool {
	_, ok := m.clearedFields[task.FieldCorrelationID]
	return ok
}

// ResetCorrelationID resets all changes to the "correlation_id" field.
func (m *TaskMutation) ResetCorrelationID() {
	m.correlation_id = nil
	delete(m.clearedFields, task.FieldCorrelationID)
}

// SetUserTasks sets the "user_tasks" field.
func (m *TaskMutation) SetUserTasks(i int) {
	m.user = &i
}

// UserTasks returns the value of the "user_tasks" field in the mutation.
func (m *TaskMutation) UserTasks() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserTasks returns the old "user_tasks" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldUserTasks(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserTasks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserTasks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserTasks: %w", err)
	}
	return oldValue.UserTasks, nil
}

// ClearUserTasks clears the value of the "user_tasks" field.
func (m *TaskMutation) ClearUserTasks() {
	m.user = nil
	m.clearedFields[task.FieldUserTasks] = struct{}{}
}

// UserTasksCleared returns if the "user_tasks" field was cleared in this mutation.
func (m *TaskMutation) UserTasksCleared() bool {
	_, ok := m.clearedFields[task.FieldUserTasks]
	return ok
}

// ResetUserTasks resets all changes to the "user_tasks" field.
func (m *TaskMutation) ResetUserTasks() {
	m.user = nil
	delete(m.clearedFields, task.FieldUserTasks)
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *TaskMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *TaskMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[task.FieldUserTasks] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *TaskMutation) UserCleared() bool {
	return m.UserTasksCleared() || m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *TaskMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *TaskMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *TaskMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the TaskMutation builder.
func (m *TaskMutation) Where(ps ...predicate.Task) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TaskMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TaskMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Task, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TaskMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TaskMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Task).
func (m *TaskMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TaskMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, task.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, task.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, task.FieldDeletedAt)
	}
	if m._type != nil {
		fields = append(fields, task.FieldType)
	}
	if m.status != nil {
		fields = append(fields, task.FieldStatus)
	}
	if m.public_state != nil {
		fields = append(fields, task.FieldPublicState)
	}
	if m.private_state != nil {
		fields = append(fields, task.FieldPrivateState)
	}
	if m.correlation_id != nil {
		fields = append(fields, task.FieldCorrelationID)
	}
	if m.user != nil {
		fields = append(fields, task.FieldUserTasks)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TaskMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case task.FieldCreatedAt:
		return m.CreatedAt()
	case task.FieldUpdatedAt:
		return m.UpdatedAt()
	case task.FieldDeletedAt:
		return m.DeletedAt()
	case task.FieldType:
		return m.GetType()
	case task.FieldStatus:
		return m.Status()
	case task.FieldPublicState:
		return m.PublicState()
	case task.FieldPrivateState:
		return m.PrivateState()
	case task.FieldCorrelationID:
		return m.CorrelationID()
	case task.FieldUserTasks:
		return m.UserTasks()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TaskMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case task.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case task.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case task.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case task.FieldType:
		return m.OldType(ctx)
	case task.FieldStatus:
		return m.OldStatus(ctx)
	case task.FieldPublicState:
		return m.OldPublicState(ctx)
	case task.FieldPrivateState:
		return m.OldPrivateState(ctx)
	case task.FieldCorrelationID:
		return m.OldCorrelationID(ctx)
	case task.FieldUserTasks:
		return m.OldUserTasks(ctx)
	}
	return nil, fmt.Errorf("unknown Task field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TaskMutation) SetField(name string, value ent.Value) error {
	switch name {
	case task.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case task.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case task.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case task.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case task.FieldStatus:
		v, ok := value.(task.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case task.FieldPublicState:
		v, ok := value.(*types.TaskPublicState)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublicState(v)
		return nil
	case task.FieldPrivateState:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrivateState(v)
		return nil
	case task.FieldCorrelationID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCorrelationID(v)
		return nil
	case task.FieldUserTasks:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserTasks(v)
		return nil
	}
	return fmt.Errorf("unknown Task field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TaskMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TaskMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TaskMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Task numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TaskMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(task.FieldDeletedAt) {
		fields = append(fields, task.FieldDeletedAt)
	}
	if m.FieldCleared(task.FieldPrivateState) {
		fields = append(fields, task.FieldPrivateState)
	}
	if m.FieldCleared(task.FieldCorrelationID) {
		fields = append(fields, task.FieldCorrelationID)
	}
	if m.FieldCleared(task.FieldUserTasks) {
		fields = append(fields, task.FieldUserTasks)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TaskMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TaskMutation) ClearField(name string) error {
	switch name {
	case task.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case task.FieldPrivateState:
		m.ClearPrivateState()
		return nil
	case task.FieldCorrelationID:
		m.ClearCorrelationID()
		return nil
	case task.FieldUserTasks:
		m.ClearUserTasks()
		return nil
	}
	return fmt.Errorf("unknown Task nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TaskMutation) ResetField(name string) error {
	switch name {
	case task.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case task.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case task.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case task.FieldType:
		m.ResetType()
		return nil
	case task.FieldStatus:
		m.ResetStatus()
		return nil
	case task.FieldPublicState:
		m.ResetPublicState()
		return nil
	case task.FieldPrivateState:
		m.ResetPrivateState()
		return nil
	case task.FieldCorrelationID:
		m.ResetCorrelationID()
		return nil
	case task.FieldUserTasks:
		m.ResetUserTasks()
		return nil
	}
	return fmt.Errorf("unknown Task field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TaskMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, task.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TaskMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case task.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TaskMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TaskMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TaskMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, task.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TaskMutation) EdgeCleared(name string) bool {
	switch name {
	case task.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TaskMutation) ClearEdge(name string) error {
	switch name {
	case task.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Task unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TaskMutation) ResetEdge(name string) error {
	switch name {
	case task.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown Task edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	created_at          *time.Time
	updated_at          *time.Time
	deleted_at          *time.Time
	email               *string
	nick                *string
	password            *string
	status              *user.Status
	storage             *int64
	addstorage          *int64
	two_factor_secret   *string
	avatar              *string
	settings            **types.UserSetting
	clearedFields       map[string]struct{}
	group               *int
	clearedgroup        bool
	files               map[int]struct{}
	removedfiles        map[int]struct{}
	clearedfiles        bool
	dav_accounts        map[int]struct{}
	removeddav_accounts map[int]struct{}
	cleareddav_accounts bool
	shares              map[int]struct{}
	removedshares       map[int]struct{}
	clearedshares       bool
	passkey             map[int]struct{}
	removedpasskey      map[int]struct{}
	clearedpasskey      bool
	tasks               map[int]struct{}
	removedtasks        map[int]struct{}
	clearedtasks        bool
	entities            map[int]struct{}
	removedentities     map[int]struct{}
	clearedentities     bool
	done                bool
	oldValue            func(context.Context) (*User, error)
	predicates          []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *UserMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *UserMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *UserMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[user.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *UserMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[user.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *UserMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, user.FieldDeletedAt)
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetNick sets the "nick" field.
func (m *UserMutation) SetNick(s string) {
	m.nick = &s
}

// Nick returns the value of the "nick" field in the mutation.
func (m *UserMutation) Nick() (r string, exists bool) {
	v := m.nick
	if v == nil {
		return
	}
	return *v, true
}

// OldNick returns the old "nick" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldNick(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNick is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNick requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNick: %w", err)
	}
	return oldValue.Nick, nil
}

// ResetNick resets all changes to the "nick" field.
func (m *UserMutation) ResetNick() {
	m.nick = nil
}

// SetPassword sets the "password" field.
func (m *UserMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *UserMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ClearPassword clears the value of the "password" field.
func (m *UserMutation) ClearPassword() {
	m.password = nil
	m.clearedFields[user.FieldPassword] = struct{}{}
}

// PasswordCleared returns if the "password" field was cleared in this mutation.
func (m *UserMutation) PasswordCleared() bool {
	_, ok := m.clearedFields[user.FieldPassword]
	return ok
}

// ResetPassword resets all changes to the "password" field.
func (m *UserMutation) ResetPassword() {
	m.password = nil
	delete(m.clearedFields, user.FieldPassword)
}

// SetStatus sets the "status" field.
func (m *UserMutation) SetStatus(u user.Status) {
	m.status = &u
}

// Status returns the value of the "status" field in the mutation.
func (m *UserMutation) Status() (r user.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldStatus(ctx context.Context) (v user.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *UserMutation) ResetStatus() {
	m.status = nil
}

// SetStorage sets the "storage" field.
func (m *UserMutation) SetStorage(i int64) {
	m.storage = &i
	m.addstorage = nil
}

// Storage returns the value of the "storage" field in the mutation.
func (m *UserMutation) Storage() (r int64, exists bool) {
	v := m.storage
	if v == nil {
		return
	}
	return *v, true
}

// OldStorage returns the old "storage" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldStorage(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStorage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStorage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStorage: %w", err)
	}
	return oldValue.Storage, nil
}

// AddStorage adds i to the "storage" field.
func (m *UserMutation) AddStorage(i int64) {
	if m.addstorage != nil {
		*m.addstorage += i
	} else {
		m.addstorage = &i
	}
}

// AddedStorage returns the value that was added to the "storage" field in this mutation.
func (m *UserMutation) AddedStorage() (r int64, exists bool) {
	v := m.addstorage
	if v == nil {
		return
	}
	return *v, true
}

// ResetStorage resets all changes to the "storage" field.
func (m *UserMutation) ResetStorage() {
	m.storage = nil
	m.addstorage = nil
}

// SetTwoFactorSecret sets the "two_factor_secret" field.
func (m *UserMutation) SetTwoFactorSecret(s string) {
	m.two_factor_secret = &s
}

// TwoFactorSecret returns the value of the "two_factor_secret" field in the mutation.
func (m *UserMutation) TwoFactorSecret() (r string, exists bool) {
	v := m.two_factor_secret
	if v == nil {
		return
	}
	return *v, true
}

// OldTwoFactorSecret returns the old "two_factor_secret" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldTwoFactorSecret(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTwoFactorSecret is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTwoFactorSecret requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTwoFactorSecret: %w", err)
	}
	return oldValue.TwoFactorSecret, nil
}

// ClearTwoFactorSecret clears the value of the "two_factor_secret" field.
func (m *UserMutation) ClearTwoFactorSecret() {
	m.two_factor_secret = nil
	m.clearedFields[user.FieldTwoFactorSecret] = struct{}{}
}

// TwoFactorSecretCleared returns if the "two_factor_secret" field was cleared in this mutation.
func (m *UserMutation) TwoFactorSecretCleared() bool {
	_, ok := m.clearedFields[user.FieldTwoFactorSecret]
	return ok
}

// ResetTwoFactorSecret resets all changes to the "two_factor_secret" field.
func (m *UserMutation) ResetTwoFactorSecret() {
	m.two_factor_secret = nil
	delete(m.clearedFields, user.FieldTwoFactorSecret)
}

// SetAvatar sets the "avatar" field.
func (m *UserMutation) SetAvatar(s string) {
	m.avatar = &s
}

// Avatar returns the value of the "avatar" field in the mutation.
func (m *UserMutation) Avatar() (r string, exists bool) {
	v := m.avatar
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatar returns the old "avatar" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAvatar(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvatar is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvatar requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatar: %w", err)
	}
	return oldValue.Avatar, nil
}

// ClearAvatar clears the value of the "avatar" field.
func (m *UserMutation) ClearAvatar() {
	m.avatar = nil
	m.clearedFields[user.FieldAvatar] = struct{}{}
}

// AvatarCleared returns if the "avatar" field was cleared in this mutation.
func (m *UserMutation) AvatarCleared() bool {
	_, ok := m.clearedFields[user.FieldAvatar]
	return ok
}

// ResetAvatar resets all changes to the "avatar" field.
func (m *UserMutation) ResetAvatar() {
	m.avatar = nil
	delete(m.clearedFields, user.FieldAvatar)
}

// SetSettings sets the "settings" field.
func (m *UserMutation) SetSettings(ts *types.UserSetting) {
	m.settings = &ts
}

// Settings returns the value of the "settings" field in the mutation.
func (m *UserMutation) Settings() (r *types.UserSetting, exists bool) {
	v := m.settings
	if v == nil {
		return
	}
	return *v, true
}

// OldSettings returns the old "settings" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldSettings(ctx context.Context) (v *types.UserSetting, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSettings is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSettings requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSettings: %w", err)
	}
	return oldValue.Settings, nil
}

// ClearSettings clears the value of the "settings" field.
func (m *UserMutation) ClearSettings() {
	m.settings = nil
	m.clearedFields[user.FieldSettings] = struct{}{}
}

// SettingsCleared returns if the "settings" field was cleared in this mutation.
func (m *UserMutation) SettingsCleared() bool {
	_, ok := m.clearedFields[user.FieldSettings]
	return ok
}

// ResetSettings resets all changes to the "settings" field.
func (m *UserMutation) ResetSettings() {
	m.settings = nil
	delete(m.clearedFields, user.FieldSettings)
}

// SetGroupUsers sets the "group_users" field.
func (m *UserMutation) SetGroupUsers(i int) {
	m.group = &i
}

// GroupUsers returns the value of the "group_users" field in the mutation.
func (m *UserMutation) GroupUsers() (r int, exists bool) {
	v := m.group
	if v == nil {
		return
	}
	return *v, true
}

// OldGroupUsers returns the old "group_users" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldGroupUsers(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGroupUsers is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGroupUsers requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGroupUsers: %w", err)
	}
	return oldValue.GroupUsers, nil
}

// ResetGroupUsers resets all changes to the "group_users" field.
func (m *UserMutation) ResetGroupUsers() {
	m.group = nil
}

// SetGroupID sets the "group" edge to the Group entity by id.
func (m *UserMutation) SetGroupID(id int) {
	m.group = &id
}

// ClearGroup clears the "group" edge to the Group entity.
func (m *UserMutation) ClearGroup() {
	m.clearedgroup = true
	m.clearedFields[user.FieldGroupUsers] = struct{}{}
}

// GroupCleared reports if the "group" edge to the Group entity was cleared.
func (m *UserMutation) GroupCleared() bool {
	return m.clearedgroup
}

// GroupID returns the "group" edge ID in the mutation.
func (m *UserMutation) GroupID() (id int, exists bool) {
	if m.group != nil {
		return *m.group, true
	}
	return
}

// GroupIDs returns the "group" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GroupID instead. It exists only for internal usage by the builders.
func (m *UserMutation) GroupIDs() (ids []int) {
	if id := m.group; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGroup resets all changes to the "group" edge.
func (m *UserMutation) ResetGroup() {
	m.group = nil
	m.clearedgroup = false
}

// AddFileIDs adds the "files" edge to the File entity by ids.
func (m *UserMutation) AddFileIDs(ids ...int) {
	if m.files == nil {
		m.files = make(map[int]struct{})
	}
	for i := range ids {
		m.files[ids[i]] = struct{}{}
	}
}

// ClearFiles clears the "files" edge to the File entity.
func (m *UserMutation) ClearFiles() {
	m.clearedfiles = true
}

// FilesCleared reports if the "files" edge to the File entity was cleared.
func (m *UserMutation) FilesCleared() bool {
	return m.clearedfiles
}

// RemoveFileIDs removes the "files" edge to the File entity by IDs.
func (m *UserMutation) RemoveFileIDs(ids ...int) {
	if m.removedfiles == nil {
		m.removedfiles = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.files, ids[i])
		m.removedfiles[ids[i]] = struct{}{}
	}
}

// RemovedFiles returns the removed IDs of the "files" edge to the File entity.
func (m *UserMutation) RemovedFilesIDs() (ids []int) {
	for id := range m.removedfiles {
		ids = append(ids, id)
	}
	return
}

// FilesIDs returns the "files" edge IDs in the mutation.
func (m *UserMutation) FilesIDs() (ids []int) {
	for id := range m.files {
		ids = append(ids, id)
	}
	return
}

// ResetFiles resets all changes to the "files" edge.
func (m *UserMutation) ResetFiles() {
	m.files = nil
	m.clearedfiles = false
	m.removedfiles = nil
}

// AddDavAccountIDs adds the "dav_accounts" edge to the DavAccount entity by ids.
func (m *UserMutation) AddDavAccountIDs(ids ...int) {
	if m.dav_accounts == nil {
		m.dav_accounts = make(map[int]struct{})
	}
	for i := range ids {
		m.dav_accounts[ids[i]] = struct{}{}
	}
}

// ClearDavAccounts clears the "dav_accounts" edge to the DavAccount entity.
func (m *UserMutation) ClearDavAccounts() {
	m.cleareddav_accounts = true
}

// DavAccountsCleared reports if the "dav_accounts" edge to the DavAccount entity was cleared.
func (m *UserMutation) DavAccountsCleared() bool {
	return m.cleareddav_accounts
}

// RemoveDavAccountIDs removes the "dav_accounts" edge to the DavAccount entity by IDs.
func (m *UserMutation) RemoveDavAccountIDs(ids ...int) {
	if m.removeddav_accounts == nil {
		m.removeddav_accounts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.dav_accounts, ids[i])
		m.removeddav_accounts[ids[i]] = struct{}{}
	}
}

// RemovedDavAccounts returns the removed IDs of the "dav_accounts" edge to the DavAccount entity.
func (m *UserMutation) RemovedDavAccountsIDs() (ids []int) {
	for id := range m.removeddav_accounts {
		ids = append(ids, id)
	}
	return
}

// DavAccountsIDs returns the "dav_accounts" edge IDs in the mutation.
func (m *UserMutation) DavAccountsIDs() (ids []int) {
	for id := range m.dav_accounts {
		ids = append(ids, id)
	}
	return
}

// ResetDavAccounts resets all changes to the "dav_accounts" edge.
func (m *UserMutation) ResetDavAccounts() {
	m.dav_accounts = nil
	m.cleareddav_accounts = false
	m.removeddav_accounts = nil
}

// AddShareIDs adds the "shares" edge to the Share entity by ids.
func (m *UserMutation) AddShareIDs(ids ...int) {
	if m.shares == nil {
		m.shares = make(map[int]struct{})
	}
	for i := range ids {
		m.shares[ids[i]] = struct{}{}
	}
}

// ClearShares clears the "shares" edge to the Share entity.
func (m *UserMutation) ClearShares() {
	m.clearedshares = true
}

// SharesCleared reports if the "shares" edge to the Share entity was cleared.
func (m *UserMutation) SharesCleared() bool {
	return m.clearedshares
}

// RemoveShareIDs removes the "shares" edge to the Share entity by IDs.
func (m *UserMutation) RemoveShareIDs(ids ...int) {
	if m.removedshares == nil {
		m.removedshares = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.shares, ids[i])
		m.removedshares[ids[i]] = struct{}{}
	}
}

// RemovedShares returns the removed IDs of the "shares" edge to the Share entity.
func (m *UserMutation) RemovedSharesIDs() (ids []int) {
	for id := range m.removedshares {
		ids = append(ids, id)
	}
	return
}

// SharesIDs returns the "shares" edge IDs in the mutation.
func (m *UserMutation) SharesIDs() (ids []int) {
	for id := range m.shares {
		ids = append(ids, id)
	}
	return
}

// ResetShares resets all changes to the "shares" edge.
func (m *UserMutation) ResetShares() {
	m.shares = nil
	m.clearedshares = false
	m.removedshares = nil
}

// AddPasskeyIDs adds the "passkey" edge to the Passkey entity by ids.
func (m *UserMutation) AddPasskeyIDs(ids ...int) {
	if m.passkey == nil {
		m.passkey = make(map[int]struct{})
	}
	for i := range ids {
		m.passkey[ids[i]] = struct{}{}
	}
}

// ClearPasskey clears the "passkey" edge to the Passkey entity.
func (m *UserMutation) ClearPasskey() {
	m.clearedpasskey = true
}

// PasskeyCleared reports if the "passkey" edge to the Passkey entity was cleared.
func (m *UserMutation) PasskeyCleared() bool {
	return m.clearedpasskey
}

// RemovePasskeyIDs removes the "passkey" edge to the Passkey entity by IDs.
func (m *UserMutation) RemovePasskeyIDs(ids ...int) {
	if m.removedpasskey == nil {
		m.removedpasskey = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.passkey, ids[i])
		m.removedpasskey[ids[i]] = struct{}{}
	}
}

// RemovedPasskey returns the removed IDs of the "passkey" edge to the Passkey entity.
func (m *UserMutation) RemovedPasskeyIDs() (ids []int) {
	for id := range m.removedpasskey {
		ids = append(ids, id)
	}
	return
}

// PasskeyIDs returns the "passkey" edge IDs in the mutation.
func (m *UserMutation) PasskeyIDs() (ids []int) {
	for id := range m.passkey {
		ids = append(ids, id)
	}
	return
}

// ResetPasskey resets all changes to the "passkey" edge.
func (m *UserMutation) ResetPasskey() {
	m.passkey = nil
	m.clearedpasskey = false
	m.removedpasskey = nil
}

// AddTaskIDs adds the "tasks" edge to the Task entity by ids.
func (m *UserMutation) AddTaskIDs(ids ...int) {
	if m.tasks == nil {
		m.tasks = make(map[int]struct{})
	}
	for i := range ids {
		m.tasks[ids[i]] = struct{}{}
	}
}

// ClearTasks clears the "tasks" edge to the Task entity.
func (m *UserMutation) ClearTasks() {
	m.clearedtasks = true
}

// TasksCleared reports if the "tasks" edge to the Task entity was cleared.
func (m *UserMutation) TasksCleared() bool {
	return m.clearedtasks
}

// RemoveTaskIDs removes the "tasks" edge to the Task entity by IDs.
func (m *UserMutation) RemoveTaskIDs(ids ...int) {
	if m.removedtasks == nil {
		m.removedtasks = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.tasks, ids[i])
		m.removedtasks[ids[i]] = struct{}{}
	}
}

// RemovedTasks returns the removed IDs of the "tasks" edge to the Task entity.
func (m *UserMutation) RemovedTasksIDs() (ids []int) {
	for id := range m.removedtasks {
		ids = append(ids, id)
	}
	return
}

// TasksIDs returns the "tasks" edge IDs in the mutation.
func (m *UserMutation) TasksIDs() (ids []int) {
	for id := range m.tasks {
		ids = append(ids, id)
	}
	return
}

// ResetTasks resets all changes to the "tasks" edge.
func (m *UserMutation) ResetTasks() {
	m.tasks = nil
	m.clearedtasks = false
	m.removedtasks = nil
}

// AddEntityIDs adds the "entities" edge to the Entity entity by ids.
func (m *UserMutation) AddEntityIDs(ids ...int) {
	if m.entities == nil {
		m.entities = make(map[int]struct{})
	}
	for i := range ids {
		m.entities[ids[i]] = struct{}{}
	}
}

// ClearEntities clears the "entities" edge to the Entity entity.
func (m *UserMutation) ClearEntities() {
	m.clearedentities = true
}

// EntitiesCleared reports if the "entities" edge to the Entity entity was cleared.
func (m *UserMutation) EntitiesCleared() bool {
	return m.clearedentities
}

// RemoveEntityIDs removes the "entities" edge to the Entity entity by IDs.
func (m *UserMutation) RemoveEntityIDs(ids ...int) {
	if m.removedentities == nil {
		m.removedentities = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.entities, ids[i])
		m.removedentities[ids[i]] = struct{}{}
	}
}

// RemovedEntities returns the removed IDs of the "entities" edge to the Entity entity.
func (m *UserMutation) RemovedEntitiesIDs() (ids []int) {
	for id := range m.removedentities {
		ids = append(ids, id)
	}
	return
}

// EntitiesIDs returns the "entities" edge IDs in the mutation.
func (m *UserMutation) EntitiesIDs() (ids []int) {
	for id := range m.entities {
		ids = append(ids, id)
	}
	return
}

// ResetEntities resets all changes to the "entities" edge.
func (m *UserMutation) ResetEntities() {
	m.entities = nil
	m.clearedentities = false
	m.removedentities = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, user.FieldDeletedAt)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.nick != nil {
		fields = append(fields, user.FieldNick)
	}
	if m.password != nil {
		fields = append(fields, user.FieldPassword)
	}
	if m.status != nil {
		fields = append(fields, user.FieldStatus)
	}
	if m.storage != nil {
		fields = append(fields, user.FieldStorage)
	}
	if m.two_factor_secret != nil {
		fields = append(fields, user.FieldTwoFactorSecret)
	}
	if m.avatar != nil {
		fields = append(fields, user.FieldAvatar)
	}
	if m.settings != nil {
		fields = append(fields, user.FieldSettings)
	}
	if m.group != nil {
		fields = append(fields, user.FieldGroupUsers)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	case user.FieldDeletedAt:
		return m.DeletedAt()
	case user.FieldEmail:
		return m.Email()
	case user.FieldNick:
		return m.Nick()
	case user.FieldPassword:
		return m.Password()
	case user.FieldStatus:
		return m.Status()
	case user.FieldStorage:
		return m.Storage()
	case user.FieldTwoFactorSecret:
		return m.TwoFactorSecret()
	case user.FieldAvatar:
		return m.Avatar()
	case user.FieldSettings:
		return m.Settings()
	case user.FieldGroupUsers:
		return m.GroupUsers()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case user.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldNick:
		return m.OldNick(ctx)
	case user.FieldPassword:
		return m.OldPassword(ctx)
	case user.FieldStatus:
		return m.OldStatus(ctx)
	case user.FieldStorage:
		return m.OldStorage(ctx)
	case user.FieldTwoFactorSecret:
		return m.OldTwoFactorSecret(ctx)
	case user.FieldAvatar:
		return m.OldAvatar(ctx)
	case user.FieldSettings:
		return m.OldSettings(ctx)
	case user.FieldGroupUsers:
		return m.OldGroupUsers(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case user.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldNick:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNick(v)
		return nil
	case user.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case user.FieldStatus:
		v, ok := value.(user.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case user.FieldStorage:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStorage(v)
		return nil
	case user.FieldTwoFactorSecret:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTwoFactorSecret(v)
		return nil
	case user.FieldAvatar:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatar(v)
		return nil
	case user.FieldSettings:
		v, ok := value.(*types.UserSetting)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSettings(v)
		return nil
	case user.FieldGroupUsers:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGroupUsers(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	var fields []string
	if m.addstorage != nil {
		fields = append(fields, user.FieldStorage)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case user.FieldStorage:
		return m.AddedStorage()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case user.FieldStorage:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStorage(v)
		return nil
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldDeletedAt) {
		fields = append(fields, user.FieldDeletedAt)
	}
	if m.FieldCleared(user.FieldPassword) {
		fields = append(fields, user.FieldPassword)
	}
	if m.FieldCleared(user.FieldTwoFactorSecret) {
		fields = append(fields, user.FieldTwoFactorSecret)
	}
	if m.FieldCleared(user.FieldAvatar) {
		fields = append(fields, user.FieldAvatar)
	}
	if m.FieldCleared(user.FieldSettings) {
		fields = append(fields, user.FieldSettings)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case user.FieldPassword:
		m.ClearPassword()
		return nil
	case user.FieldTwoFactorSecret:
		m.ClearTwoFactorSecret()
		return nil
	case user.FieldAvatar:
		m.ClearAvatar()
		return nil
	case user.FieldSettings:
		m.ClearSettings()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case user.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldNick:
		m.ResetNick()
		return nil
	case user.FieldPassword:
		m.ResetPassword()
		return nil
	case user.FieldStatus:
		m.ResetStatus()
		return nil
	case user.FieldStorage:
		m.ResetStorage()
		return nil
	case user.FieldTwoFactorSecret:
		m.ResetTwoFactorSecret()
		return nil
	case user.FieldAvatar:
		m.ResetAvatar()
		return nil
	case user.FieldSettings:
		m.ResetSettings()
		return nil
	case user.FieldGroupUsers:
		m.ResetGroupUsers()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 7)
	if m.group != nil {
		edges = append(edges, user.EdgeGroup)
	}
	if m.files != nil {
		edges = append(edges, user.EdgeFiles)
	}
	if m.dav_accounts != nil {
		edges = append(edges, user.EdgeDavAccounts)
	}
	if m.shares != nil {
		edges = append(edges, user.EdgeShares)
	}
	if m.passkey != nil {
		edges = append(edges, user.EdgePasskey)
	}
	if m.tasks != nil {
		edges = append(edges, user.EdgeTasks)
	}
	if m.entities != nil {
		edges = append(edges, user.EdgeEntities)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeGroup:
		if id := m.group; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeFiles:
		ids := make([]ent.Value, 0, len(m.files))
		for id := range m.files {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeDavAccounts:
		ids := make([]ent.Value, 0, len(m.dav_accounts))
		for id := range m.dav_accounts {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeShares:
		ids := make([]ent.Value, 0, len(m.shares))
		for id := range m.shares {
			ids = append(ids, id)
		}
		return ids
	case user.EdgePasskey:
		ids := make([]ent.Value, 0, len(m.passkey))
		for id := range m.passkey {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeTasks:
		ids := make([]ent.Value, 0, len(m.tasks))
		for id := range m.tasks {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeEntities:
		ids := make([]ent.Value, 0, len(m.entities))
		for id := range m.entities {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 7)
	if m.removedfiles != nil {
		edges = append(edges, user.EdgeFiles)
	}
	if m.removeddav_accounts != nil {
		edges = append(edges, user.EdgeDavAccounts)
	}
	if m.removedshares != nil {
		edges = append(edges, user.EdgeShares)
	}
	if m.removedpasskey != nil {
		edges = append(edges, user.EdgePasskey)
	}
	if m.removedtasks != nil {
		edges = append(edges, user.EdgeTasks)
	}
	if m.removedentities != nil {
		edges = append(edges, user.EdgeEntities)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeFiles:
		ids := make([]ent.Value, 0, len(m.removedfiles))
		for id := range m.removedfiles {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeDavAccounts:
		ids := make([]ent.Value, 0, len(m.removeddav_accounts))
		for id := range m.removeddav_accounts {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeShares:
		ids := make([]ent.Value, 0, len(m.removedshares))
		for id := range m.removedshares {
			ids = append(ids, id)
		}
		return ids
	case user.EdgePasskey:
		ids := make([]ent.Value, 0, len(m.removedpasskey))
		for id := range m.removedpasskey {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeTasks:
		ids := make([]ent.Value, 0, len(m.removedtasks))
		for id := range m.removedtasks {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeEntities:
		ids := make([]ent.Value, 0, len(m.removedentities))
		for id := range m.removedentities {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 7)
	if m.clearedgroup {
		edges = append(edges, user.EdgeGroup)
	}
	if m.clearedfiles {
		edges = append(edges, user.EdgeFiles)
	}
	if m.cleareddav_accounts {
		edges = append(edges, user.EdgeDavAccounts)
	}
	if m.clearedshares {
		edges = append(edges, user.EdgeShares)
	}
	if m.clearedpasskey {
		edges = append(edges, user.EdgePasskey)
	}
	if m.clearedtasks {
		edges = append(edges, user.EdgeTasks)
	}
	if m.clearedentities {
		edges = append(edges, user.EdgeEntities)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeGroup:
		return m.clearedgroup
	case user.EdgeFiles:
		return m.clearedfiles
	case user.EdgeDavAccounts:
		return m.cleareddav_accounts
	case user.EdgeShares:
		return m.clearedshares
	case user.EdgePasskey:
		return m.clearedpasskey
	case user.EdgeTasks:
		return m.clearedtasks
	case user.EdgeEntities:
		return m.clearedentities
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	case user.EdgeGroup:
		m.ClearGroup()
		return nil
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeGroup:
		m.ResetGroup()
		return nil
	case user.EdgeFiles:
		m.ResetFiles()
		return nil
	case user.EdgeDavAccounts:
		m.ResetDavAccounts()
		return nil
	case user.EdgeShares:
		m.ResetShares()
		return nil
	case user.EdgePasskey:
		m.ResetPasskey()
		return nil
	case user.EdgeTasks:
		m.ResetTasks()
		return nil
	case user.EdgeEntities:
		m.ResetEntities()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}
